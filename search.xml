<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1901020029-MIT60001-Day1-10]]></title>
    <url>%2FMIT60001%2F1901020029-MIT60001-Day1-10%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020029 学习内容：MIT6.0001课程 1-10天打卡 学习用时：20小时 学习笔记第一天：20190624学习时间：3小时学习内容：MIT Lecture 1学习收获：1、从上周开始学习MIT课程，Lecture1听了3遍，第一遍跟英文字幕，发现无法理解课程，后两遍跟中文字幕，尽可能理解课程讲解的内容。2、陈述性知识：陈述事实。程序性知识：即配方，如何做。3、什么是一个配方？包含简单的步骤、每一步被执行时的控制流、以及用什么方式停止程序。4、计算器是固定程序的计算机，只会计算；电脑则是储存程序的计算机，可以进行机器存储和执行指令。5、理解计算机的基本体系架构。6、编程语言与英语语言类比：数字、字符串、简单的运算符就像英语里的单词，是编程语言的原始构件；原始构件的组合要符合语法结构，数字和字符串组合在一起会导致语法无效；编程语言只能有唯一的含义。7、复习数据、对象（标量对象、非标量对象）类型、类型转换、打印命令、表达式、数值运算、=（赋值）的含义、变量这些基本概念。遇到的难点：1、英语仍是拦路虎，畏难心理有点严重。课程用中文字幕听完后，打开PPT来仔细阅读，还是有许多看不懂的地方。2、psets 是 problem sets 的缩写吗？是问题集合的意思吗？3、练习题1、2做完，第一次使用Spyder，练习题3的视频在打开时没注意，点成用默认的QuickTime player播放，对文件进行了转码，然后就遭遇意外无法打开。我尝试重新在钉钉上下载lecture文件，重新解压，依然无法解决此问题。 第二天：20190625学习时间：2小时学习内容：MIT Lecture 2学习收获：1、快速过一遍Lecture1pdf，读不懂的英文努力理解一下。2、字符串对象类型包括字母、特殊字符、空格、数字；需要封装在双引号或单引号中；用+来连接，其中的空格必须用“ ”来实现；用 * num 来实现字符串的num次重复。3、用print( )实现在控制台的输出，括号内的输出内容字符串需有引号，用+拼接的内容之间无空格，用，连接的内容之间显示空格。4、用input(“ ”)进行人机交互，提示用户按引号内的内容输入并回车，将用户输入绑定到一个变量；默认用户输入为字符串类型，如果需要数字类型，需要转换。5、对象类型之间可以用比较运算符连接成表达式，最后评估为布尔值，真或假。6、控制流实现程序的分支。用if…、if…else…、if…elif…else…来实现。7、for循环：知道迭代数量；能用break结束；使用一个计数器；用while循环可以重写一个for循环。8、while循环：可无限数量的迭代；能用break结束；可以使用一个计数器但是必须在循环之前初始化计数器并在循环内部递增它；用for循环可能不能重写一个while循环。疑问：昨天想问，但忘记问了，这个课程的名称里6.0001的含义是什么？ 第三天：20190626学习时间：2小时学习内容：MIT Lecture 3前半部分学习收获：1、逐渐理顺学习节奏，先用中文跟视频尽量理解，再仔细阅读pdf，消灭生词。2、对字符串数据类型的处理：把其当作大小写敏感的字符序列；可以用运算符==、&gt;、&lt;等进行比较；可以用len( )函数检索字符串的长度；可以用[ ]索引到字符串内指定的位置；字符串不可以被修改。3、其中关于字符串切割的例子 s [4：1：-2 ]，开始怎么也绕不明白，后来去查阅The Python Tutorial的讲解，终于明白了。4、做随堂练习是检验自己到底懂没懂的最好方法，今天去公开课网站做前两个Lecture的IN-CLASS questions，发现虽然代码都尝试运行过，但是题还是会答错，说明原理并没有理解透彻。5、践行“不耻下问”的结果很赞，前天关于psets的疑惑，问之前各种担心会不会太小白，会不会被笑话，结果得到了热心同学的解答，确定是问题集合后，也在想这个psets在哪里？今天在公开课网站上找到了ASSIGNMENTS里的psets，接下来要多多练习了。6、这几天多看、多读、多想的结果就是真的不那么怕英语啦，能明显感觉到自己通过英语能理解的东西越来越多了。7、小伙伴们一起来打卡啊，加油！ 第四天：20190627学习时间：2小时学习内容：MIT Lecture 3后半部分学习收获：1、学习三种不同的算法，理解计算机如何帮助我们解决具体的问题。三种算法为猜测和检查、近似算法、以及二分搜索法。2、近似算法是为了寻求一个足够好的答案，在求解立方根的例子中，给定一个epsilon变量，给定一个增量值increment变量，如果增量值过小会导致程序很慢但结果的准确度很高，如果增加epsilon范围，则会降低结果的准确度，但能更快得到答案。3、二分搜索法老师以0-100之间的猜数游戏为例，讲解这样的求解方法可以快速降低搜索范围，以对数的形式降低猜测次数，不同于遍历每一个数据进行猜测的线性的猜测检查法和近似解决法，强大的二分法能更快速的获取答案。4、几个用于理解不同算法的代码案例，反反复复看了很多遍，也运行了所有的代码，换不同的数据体验结果有何不同，感觉每看一遍都有不同的理解。 第五天：20190628学习时间：2小时学习内容：MIT Lecture 4前半部分学习收获：1、重点内容：结构化程序及隐藏的细节；函数；说明书；关键词return vs print；范围。2、先用投影仪的例子来帮助我们理解编程中分解decomposition和抽象abstraction的概念。3、超大型舞台需要很多台投影仪协同工作，每台投影仪的内部处理完全相同，但给每台投影仪输入不同的内容，最后不同的投影结果组合出完美的舞台成像。4、好程序不是指更长的代码，而是能提供更多的功能。实现机制就是分解和抽象。5、在编程中用分解创造结构。代码被分解成模块modules，模块是独立的、用于分解代码、计划重复使用、有组织的、连贯一致的。函数functions和类classes可以实现分解。6、在编程中用抽象来隐藏细节。把一块代码理解为黑盒，不用管其内部细节，会看函数说明书或字符串文档，知道怎么用这块代码实现想要的功能就可以了。7、可反复使用的代码块叫函数，函数在程序中不运行，除非函数被调用。8、函数的特征：有名字、有参数（0或更多）、有说明文档（可选项但推荐有）、有主体、返回某物。 第六天：20190629学习时间：1小时学习内容：MIT Lecture 4后半部分学习收获：1、理解变量作用域，嵌套的变量作用域例子有点绕不清。2、当函数被调用时，形参被绑定到实参的值。3、当进入一个函数，新作用域/框架/环境创造出来。4、作用域是对象名称的映射。5、程序先列出全局变量，函数的值是一些代码，然后是各个变量的值，当变量在调用函数时，就进入被调用函数的局部变量作用域，程序开始列出函数内部的变量，直到函数的返回值，这个函数的返回值回到主程序的函数变量里。6、没有return陈述的一个警告：如果函数没有return陈述，python返回值None。 第七天：20190630学习时间：30min学习内容：MIT Lecture 5前半部分学习收获：1、理解两个新的数据类型：元组 ( ) 和列表 [ ]。2、元组一旦创建其值不可更改；列表的值是可变的。3、元组和列表的元素可以像字符串一样进行索引、定位、切割等。4、列表的值可改变这一点使列表对象非常有用。5、添加列表元素用L.append（element）6、只是听课（跟中文字幕）来理解课程有点困难，周末时间严重不够用。7、感觉前几课的内容因为训练营突击学习过，大概了解最基础概念，听课程加看pdf能比较好理解，今天的感觉到吃力，后续学习是应该继续跟课程，先听一遍下来，还是巩固复习前面的内容，花时间做练习，彻底搞懂再继续？感觉自己又犯了究细节的毛病，而忘记了全面和完整，听不懂也应该先听一遍不是吗？但是最大的难点在于不懂如何写收获。 第八天：20190701学习时间：3小时学习内容：MIT Lecture 5视频前30min + PPT（p1-p16）学习收获：1、重新复习元组、列表这两个复合数据类型。昨晚只是跟字幕听视频感觉头脑很混乱，今天放慢速度，边听边看pdf，做到理解内容。2、元组：有序的元素序列，可以混合不同的元素类型；不能改变元素的值，同字符串一样，一旦创建是不可变的；用( )代表元组。3、注意：元组 t = (2,“mit”,3）经t [1:2]切割后值为(“mit”, ）这里额外的逗号意味着它是一个元素的元组，而不是字符串。4、元组用于替换两个变量的值非常方便，(x,y)=(y,x)一行代码即可实现。否则想替换变量x、y的值，必须设置一个临时变量才能实现。5、利用元组可以实现从函数中返回多个值。6、元组中嵌套元组元素，进行遍历元组数据，对处理真实世界的数据非常有用。这点需要运行代码实例才比较好理解元组实现的功能。7、列表是有序的信息序列，可索引；用[ ]表示；通常包含同类元素，也可以包含混合的元素；列表是可改变的。8、像字符串一样，可以用更pythonic的语言来遍历列表，计算列表元素的总和。for i in L：9、有关列表的操作：用L.append(element)实现在列表L后添加element；用+实现两个列表的组合；用L.extend(some_list)实现在列表后扩展一些清单；用del(L[index])删除索引位置的元素；用L.pop( )实现返回列表的最末尾元素，并将L改变为去除最末尾元素的新列表；用L.remove(element)实现查找第一个出现的element，并去除它，如果元素不存在，则报错。10、列表与字符串之间的互转：用list(s)实现将字符串s的每个字符转变为列表元素；用s.split( )实现在字符串中某个字符处将其分解为两个元素的列表；用‘ ’.join(L)实现将列表L转变为字符串;用’’.join(L)实现在转变为字符串的字符之间添加用sorted(L)实现对列表L的排序，列表L没有改变；用L.sort( )实现对列表L的排序，列表L改变；用L.reverse( )实现对列表L的反转，列表L改变。心得：1、心静下来，理解力明显上升。2、视频中的代码示例一定要亲自运行，并修改数据来试验结果，有助于提高对代码的理解。3、遇到中文字幕拗口不好理解时，配合pdf来理解效果更佳。 第九天：20190702学习时间：2小时学习内容：MIT Lecture 5后10min + PPT(p16-24)学习收获：1、列表对象具有可变性，不同于字符串、元组等不可变对象。2、变量名仅是贴在对象上的标签，对象变了，指向对象的标签都受影响。3、用列表对象进行具体操作时会产生某些副作用。4、理解别名现象，比如warm和hot指向同一个列表对象，使用append()函数改变hot变量时，warm变量也改变了。5、针对列表可变性，克隆列表是很有用的方法。用[:]实现，比如hot= warm[:]，这样改变hot时，warm仍是原来的列表对象。6、对列表排序调用sort()函数改变列表，返回None；调用sorted()函数不改变列表，但必须分配值给变量。7、列表嵌套列表，在实际工作中要时刻注意副作用的问题。8、做exercise。 第十天：20190703学习时间：2小时学习内容：MIT Lecture 6（主题：递归，字典）前10min + PPT(p1-p13)学习收获：1、老师换成了Eric Grimson，一下有点不适应。2、理解递归RECURSION，是把规模大的问题转化为规模小的相似的子问题来解决。在函数中，就产生了函数调用它自身的情况。此外，这个解决问题的函数必须有结束条件，否则会产生无限递归。3、之前已经学了循环结构(for、while)来迭代算法，按照一套状态变量在每次迭代循环时更新来捕获计算。4、举例：展示乘法a*b和计算阶乘n！分别用迭代求解方案和递归求解方案是如何一步步实现的，学习递归的解题思维。5、时间主要花在网上阅读有关递归的文章，帮助理解递归的思想。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050107-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050107-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：党聪学号：1901050107 工作背景培训讲师 自我介绍15年大学毕业后做过一段时间的程序员，但是由于没有找到突破的路径和状态所以放弃了，后来辗转各个行业探索，尝试，但是发现真正想变得厉害就得像笑来老师这样，需要什么就去学，不问喜不喜欢，只问学没学会。 目前已经学完了入门训练营，MIT 13节课，在此阶段，我找到了钻研的感觉，找到了输入，实战，输出的流畅的感觉，这是我之前从未有过的。臆测一下：任何学习必须是链式反应，就是上一个阶段的学习必须是下一个阶段学习的原动力，而非阻力。 学习目的一：转行回到互联网行业，回到最容易做出成绩的赛道 在这一阶段学习结束后，我会找一份数据分析师的工作。因为我发现个人的价值首先是由社会的需求决定的，其次才是自己的努力程度。我原本以为只有新兴行业才会用到数据分析，但是经过这几个月的观察发现几乎各行各业都会用到。 二: 学以致用，围绕技能构建系统认知 向笑来老师学习，就编程一项技能做出了这么多产品，这些产品共同组成了一个能够自己生长的系统， 我原来做程序员的时候很傻很单纯，既没有社交，又不会主动把技能用到其他的地方，所以是一种消耗似的工作。但是现在，我尝到了甜头，一方面Python能做很多事，简直不要太好玩。另一方面，很多朋友听说我学习Python都想让我做点儿东西。虽然大部分需求我还满足不了，但是我相信我很快就能跟进。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>培训讲师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020029-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020029-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王媛学号：1901020029 工作背景从事生物制品质检、质量管理及一线销售工作共计16年。 自我介绍我叫王媛，一直在医药行业工作，如今作为一个4岁男孩的妈妈，我希望自己能真正学成一门手艺，用自己不断自学成长的经历来做孩子的榜样！ 学点编程，我相信学了总比不学强！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>孩子母亲</tag>
        <tag>医药行业</tag>
        <tag>质量管理</tag>
        <tag>一线销售</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet3(P2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet3(P2)%20%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 3 (ZIP) 打卡天数：D09 作业(Problem 2: Dealing with hands):Removing letters from a hand (you implement this!) The player starts with a full hand of n letters. As the player spells out words, letters from the set are used up. For example, the player could start with the following hand: a, q, l, m, u, i, l The player could choose to play the word quail. This would leave the following letters in the player’s hand: l, m. You will now write a function that takes a hand and a word as inputs, uses letters from that hand to spell the word, and returns a new hand containing only the remaining letters. Your function should not modify the input hand. For example: 12345678910&gt;&gt; hand = &#123;'a':1, 'q':1, 'l':2, 'm':1, 'u':1, 'i':1&#125;&gt;&gt; display_hand(hand) a q l l m u i&gt;&gt; new_hand = update_hand(hand, 'quail')&gt;&gt; new_hand &#123;'l': 1, 'm': 1&#125;&gt;&gt; display_hand(new_hand)l m&gt;&gt; display_hand(hand) a q l l m u i 作业心得作业要求，实现update_hand函数，根据作业中的提示，可以通过 copy 函数来实现次函数的功能。 学习的新函数： Python dict.copy 函数: 复制dict，修改新的dict不会影响原来的数据; ceil() Python del 函数: 删除 dict 中对应key的项 程序代码1234567891011121314151617181920212223242526272829303132## Problem #2: Update a hand by removing letters#def update_hand(hand, word): """ Does NOT assume that hand contains every letter in word at least as many times as the letter appears in word. Letters in word that don't appear in hand should be ignored. Letters that appear in word more times than in hand should never result in a negative count; instead, set the count in the returned hand to 0 (or remove the letter from the dictionary, depending on how your code is structured). Updates the hand: uses up the letters in the given word and returns the new hand, without those letters in it. Has no side effects: does not modify hand. word: string hand: dictionary (string -&gt; int) returns: dictionary (string -&gt; int) """ new_hand = hand.copy() word = word.lower() for letter in word: v = new_hand.get(letter) if v is not None: if v == 1: del new_hand[letter] else: new_hand[letter] -= 1 return new_hand]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090043-自学训练营学习9群-PYTHON入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901090043-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A09%E7%BE%A4-PYTHON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901090043 学习内容：14天python入门营 学习用时：35小时 学习笔记 自学往事如果人一生中最应该掌握的技能就是自学能力，多年来对学习有相当的信仰，只是李笑来老师把自学能力当做一种能力，并且掌握和变现了这种能力，令人震惊！在对一件事情上执着，并努力做到世界水平，这是每个人都应该学习的勇气。之前学过cSharp，Java，ps，微软办公软件，写作，阅读……由于没有系统方法论，以及对这种方法的研究意识，错过了多少美好时光，人说掌握一个技能，就拥有了另一个新世界，回想下，失去了多少个本可以拥有的世界啊。”种棵树的最好时间是十年前，其次就是现在。” 自学心得从小家里就反对我成群结伴，老家的话叫“上伴”，看到你跟几个伙伴一起聊天开心玩耍，就会说：“不要上伴啊！”我父亲有时还会当场发飙，导致我从小面对父亲就害怕，到现在而立之年有时都害怕……小时候当然不以为然，从小受到”寓教于乐“的毒，总是从心里这样说服自己，现在想来，不要上伴和现在的无效社交一样，还真是充满智慧。在我的字典里，耐心和急于求成是相对的，年轻时候每个人都胸怀大志，都要成为人上人，从几万年前的智人开始一直是这样，这是天性！这种天性导致什么呢？就是攀比啊，想立刻成为闪耀的明星啊，于是就急于求成啊，一旦不能如愿，便不开心了，受打击了，我相信99%的人都是这么个过程，实在不行就放弃了。没想通这个道理的，到死都是一事无成的！现在读书，动不动一天一本书，想想之前上学的时候吧，半年才读一本书，大部分还学不好，李笑来老师有句话：慢就是快，快就是无。没学好的症结在这里，不够慢！耐心的深入理解一个概念，一个公式，内化成自己大脑的一部分。所以说耐心是一种态度和心法，学习每个知识之前，在心理建设上，说服自己要耐心！慢慢建立自己的金字塔，这会是一个复利效应，相信我，你会学的越来越快！ 学习步骤 模仿–成果–熟练–内化为自己的大脑结构一切学习都是从模仿开始的，不模仿你怎么开始呢？你连提问都不知道怎么提，是吧？许岑在他的《如何培养你的研究能力》课程说过，要建立作品意识，这是什么意思呢？作品就是你学习的效果，也是学习反馈的一部分。举个例子：学习python编程，作品就是你写的一个一个的程序，写一个总结一下写程序的心得体会，完成一个作品，成就感从何而来，从你的作品而来。学习效果怎么得到反馈，从作品和目标作品的对比而来呀。没对比就没有前进的目标啊，从对比中反复修正自己的作品，这个就是反馈，不是什么神秘的东西！我们学习的目标是什么，是学以致用嘛，把知识内化为技能，熟练是指标，反复练习是桥梁！学会了也就会了，会伴随终身的，想想骑单车，游泳吧，这两个技能你一辈子也忘不了。 学习的每一步需要反复打磨，慢就是快，快就是无知识要成为自己的一部分，要从身体上长出这么个东西，是多么困难！想到这里也没什么害怕的，不就是和时间做朋友，反复思考，反复练习嘛！这是成长的唯一路径，或者自学的唯一路径，至于说效率，你会想这么做多慢啊！是慢，前期慢，越过一个瓶颈期会越来越快，重要的是坚持！再推荐李笑来老师的一篇文章《为什么同样都是爱读书你却总是没进步？》 学会提问从一无所知到渐入佳境，到走上”巅峰“，有篇文章写得好，跨越鸿沟，你需要的只是提问！看到这篇文章之后，心里开心了一下，看见3岁小孩哭闹淘气再也不心烦了，心想，你就淘气去吧，等你稍大点，我给你传授万金油心法，可以让你跨阶层，跨学科，立于不败之地……想起自己读书的时候，有问题再怎么思考就是不问，那时想要的是锻炼自己的思维能力，以为锻炼好了能解决一切问题，现在想来佩服那时的自己，世界果真是那样的话，世界大统一理论早就铸就出来了，万有引力、相对论全都靠边站了…… 总结不需要学会学习知识，完成作品需要进行总结，总结没有什么大用处，就是让思维更清楚，更有信心！这是心理建设的一部分！怎么说呢？学会知识和技能，一通学习完，头脑混乱，隐约是懂了的，真要说什么，那就没什么说的了，什么都没记住！你都不知道自己是会了还是不会，是真懂还是假懂？这时不要急躁，耐心做下总结。做过了肯定印象深刻，再总结下，思路就清晰了，而且心里有它了。感觉是真学会了的，感觉对头了，你就会更倾向去用它。 时间需要管理吗？学习也需要管理学习从来不是学习本身，学习是个系统工程，不是单一简单问题，头痛医头脚痛医脚这种思维太局限。学习得考虑各个方面的因素：学习环境，学习时间安排，情绪，反馈，记录，积极性，会提问题……和学习相关的比不相关的都多呢！如果人这辈子什么最重要，当然是学习，越厉害的人越会学习，学习需要学习的，但不只是学习学习，身体的管理，比如要多运动，情绪管理，乐观，心胸宽广，不要被无所谓的事情消耗自己的意志力。批判思维，怎么思考对错怎么看待有用没有用，每个知识对每个人的重要程度是不一样的，与三观不符的话，相信我，你很难坚持的，如果为此你过得很痛苦，那学习有什么意思呢？学习这件事是困难的，但不是痛苦的。人生中学习最重要，学习是生活的一本分，是活着的一部分，如果活的抑郁了，说明任督经脉没打通啊！ 学到内容 项目 知识点 总结 Github Github,Github Desktop Github是最好的陌生协作平台(分布式版本控制系统)，Desktop方便本地化修改编辑 Anaconda VSCode 环境配置，pip安装python3 VSCode是个方便强大的开发工具，里面扩展很多，界面友好 calculator计算器 python文本编辑，input(),strip() python语言简单，学会了两个方法，python对文本对齐要求很高 打印9*9乘法表 print(‘’,end=’ ‘),string.center() 知道print方法有个end参数，字符串打印居中center()方法 文本统计，字符串处理 字典，正则表达式，string.replace(‘’,’’,count),range(,),sorted(text,key=,reverse=),’’.join(array[]),bin(),oct(),hex() 正则表达式简单而强大 文本统计排序 path库abspath(),with……as……：，dict(dic,**dic1),import模块导入 path获得当前路径，文件的读取，字典的合并，和模块导入 异常处理 raise ValueError(),try: except ValueError as result 知道抛出异常，捕获异常 Counter().most_comment(count) collections.Counter库 counter()方法简单强大，优于sorted() 分词 jieba库，jieba.cut() jieba智能分词很好用 解析微信文章获得文本，发送邮件 pyquery.PyQuery response=requests.get(url,vertify=),PyQuery(response.text,ya=yagmail.SMTP(),ya.send()) 解析网络文章获得有意义的统计，很有用！ 通过微信好友发送的文章获得url，回复分析文本 wxpy库，Bot(cache_path=True),@bot.register(chats=[Friend],embed()) 监听微信好友或群消息，wxpy还有很多有趣功能待挖掘 通过微信好友发送的文章获得url，回复分析图表 nupy库,matplotlib.pyplot库 以图表图片的形式发给好友，思路：保存分析图片到本地，然后msg.reply_image(path)发送给好友]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：金志坚学号：1901020043 工作背景医药行业，从事营销推广工作 自我介绍今年42岁，除了日常的管理工作所需，最想学好的就是英语和编程，一法通万法通，通过学习编程提高自己的自学能力，希望能保持终身学习的能力，也希望能给员工展示一切皆有可能，年龄不是问题。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>营销推广</tag>
        <tag>工程师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090059-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901090059-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Charles 工作背景担任7年左右的老师，期间学生总数约有过千人，基本反馈尚算正向。 离开学校后，基本微电子行业待着，也就目前贸易战的核心内容标的之一。期间做过设计、带过团队；担任过设计工程师、技术支持工程师、研发经理等职务。从业过的公司有芯片制造的、EDA工具开发的和设计公司。 自我介绍平时喜欢阅读，尤其喜欢心理学、金融学及企业经理管理方面的书籍。 喜欢行在旅途中的美好感觉。喜欢约两三亲友，闲聊。喜欢矗立窗前听雨。 喜欢每天的坐享，经过近1年半左右的持续坐享，深深体会到她给我身心带来的积极影响和变化。 人生美好，值得付出，值得努力! 希望突破一下自己，给自己一个挑战。学习数据分析可以让自己站在新人生高度。希望学完之后一方面可应用于解决工作中碰到的问题；另外一方面希望可以基于此进行行业或者企业分析、投资分析方面。在学校期间有一定的处理器结构、嵌入式编程的基本经验，也了解过关于数据库的一些基本概念，完成了14天自学Python入门营课程，目前正在阅读Python Tutorial及MIT 60001的课程学习。主要的学习困惑是如何具备实际应用项目的工程研发能力。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>工程师</tag>
        <tag>老师</tag>
        <tag>微电子行业</tag>
        <tag>研发经理</tag>
        <tag>喜欢阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100088-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100088-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：罗禹 工作背景医疗器械注册临床研究员，靠循证医学和撰写Meta分析与临床试验方案吃饭，日常检索数据、分析数据，解释评价数据来证明医疗器械的安全及有效性。 自我介绍接触python好几年了，但每次长期卡壳后就暂停学习了，间隔好久又重启。想在今年内彻底搞定编程及python的入门及运用。 程序的日常工作运用场景1.数据获取及爬虫：日常需要检索同类医疗器械信息、文献、不良事件及召回信息、监管数据。对于各国的监管数据，爬虫获取远比手工检索高效。2.数据分析：工作中需要做森林图和漏斗图，现阶段使用的数据分析软件是RevMan和SPSS，正在向SAS和Stata转换，涉及到程序。3.大数据：临床评价统计学方法学上一个发展方向是真实世界研究。工作中查询的关节登记数据库实质就是各个国家的确关节置换方向的大数据统计结果。4.数据库建立。5.医疗器械研发方向；6.人工智能：国家对创新类医疗器械优先审评，对人工智能医疗器械在不断推进。国药监对标准化公示了归口单位，也召开了人工智能创新推进会。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医疗器械</tag>
        <tag>注册</tag>
        <tag>临床评价</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020015-自学编程阶段性总结：终于找到“浸泡”式学习英语的机会，开启跨越自己的旅程]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901020015-%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%88%E4%BA%8E%E6%89%BE%E5%88%B0%E2%80%9C%E6%B5%B8%E6%B3%A1%E2%80%9D%E5%BC%8F%E5%AD%A6%E4%B9%A0%E8%8B%B1%E8%AF%AD%E7%9A%84%E6%9C%BA%E4%BC%9A%EF%BC%8C%E5%BC%80%E5%90%AF%E8%B7%A8%E8%B6%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%85%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[阶段性总结 写在前面的话：致所有看到这个文章的伙伴。请原谅我的自私，想要以书信的口吻写给曾经的（上一刻的）自己。如果你不禁笑出了声，感谢你的认同和感同身受。 Dear, 李浩天 想了很久，还是觉得以 “阶段性总结” 这个标题起笔比较好。我想你已经明白不管是Python还是自学能力，它就像英语一样是一个需要不断使用、不断强化和迭代的工具。那在今天这个时刻所需要跨越的我想也许就和财富自由一样，只是一个里程碑而已，跨越过去还有更多的事情要做，更长的路要走。 开始 还是想和你聊聊开始，但也许并不像你想的那样，开始真的不应该在完成选择的那一刻。 我知道最开始的时候，你一定觉得选择加入自学训练营还挺偶然的。但你有没有想过也许就像《The Secret》里面一样，这个世界好像有一个”Attraction law”。而这个Attraction的源头就是你自己的内心。 我想你一定还记的，在很早的时候你心里面就被种上了那颗种子。我真的已经记不清是什么时候了，只是隐约的记得那是某一次你的父亲带着你参加一个演讲的时候，在讲台上的老师说到的。 —— “ 一个人的学历代表他的过去，财力代表他的现在，只有学习力才能代表他的将来”。 我想你一定笑了，因为你明白它已经在你的生命中生根发芽。我看的到，其实你并不过分的信赖所谓的“经验”和“资历”，但你会尊重并观察它们。你认为每一个经验的背后都有其自己成长的背景，也有值得学习和改善的地方。 还记得吗，在你刚毕业半年的时候。你加入一家广告营销咨询公司，开始的时候只是一个项目执行，然后一个月后涨薪，实习期过后升为SA，半年后带团队拿到部门70%的项目。我知道你当时很自豪，也很傲慢。会觉得是因为自己有“自学能力”所以可以快速超越。 我想现在你一定明白了自己当时的傻逼，当静下心来，你才会想起很多的细节。其实你当时只是有学习的态度而已，当时的你真的不知道如何去体系化的、深入的去学习，只不过是有态度所以你的领导愿意带你，你真正感谢的应该是教你学会当时需要的东西的那个领导。啊……我想经过了这些年，你也一定会发现 仅仅有学习的态度，并且愿意花费时间和精力这一项粗浅的特质其实已经可以超越很多人，因为它会让你向前看让你不会离”鄙视链”那么近 （真的不敢说远离） 我们再来聊聊这次你认为的偶然吧。我记得当时的你很迷茫，想要找到一个机会可以以“浸泡”的方式来开启英语，而不是像之前那样反反复复只学不用，同时你也总是想拾起大学时学习的编程知识可也不知道应该从哪里开始。也许当时的你并没有想到可以有这样的一个结合。直到那天晚上： 女票发来消息说：这个东西你看一下，应该你会喜欢的。然后……你就报名了…… 是不是回过头来，感觉好突然，似乎没有做什么迟疑和判断，所以你说这是一个偶然。但我想说 —— 不，这是一个必然。事情的发生其实和选择无关，相同的事情不同的人可能会做出相反的选择。而所有的选择都是根深蒂固在自己内心的观点和认知，所以我说这个的开始真的不是在完成选择的那一刻。 共同成长的14天 原本的小标题是“成长的14天”，但后来改为了“共同成长的14天”，因为这里面不仅仅是你和我的成长，我想更是和每一个一起走过着14天的战友们一起的成长。这里面不可能更不应该只有你的影子对吧。 我想对你来说，最难的应该就是开始的3天了吧。纯英的资料、没有接触过的工具、陌生的词汇，不仅仅对你的时间是一个挑战，更不断地，不断地，不断地打击着你的自信心，让你觉得“我怎么这么蠢，这东西怎么这么难”。我看的到，当时的你不断的在‘对未来的恐惧’、‘对自我的怀疑’、‘内心的自我安慰和鼓励’这三种状态中不断的切换，你想过放弃，但很庆幸你坚持下来了。 请原谅我使用 “坚持” 这个词，我知道你并不喜欢甚至不认同。但我还是想说所有的“坚持”都是存在的，只不过在不同的情景下它转化为了不同的样子。当你以爱好开始那个坚持叫做“想知道”，当你以任务开始那个坚持叫“目标”，当你以被迫开始那个坚持叫“自我安慰”。但是我们都清楚，如果可以走的足够长或者做的足够好那这个坚持一定会被叫做 “根本停不下来”。它将成为你的标签，满足你的内心并支撑你的生活。 说到这里，我不禁想起了那天差点“玩坏微信”的你。应该是Day12，那天的作业是通过微信的文章链接，将文章内容读取出来并统计词频输出。 最开始是惊奇 —— 哇哦，原来还可以这样。然后你用wxpy获取了自己的所有的好友信息，还拍了个视频发给好些个好友，去解释为什么不要随便用微信扫一扫，并通过微信机器人和好友聊天，还发了个朋友圈去指点江山 —— “The code is the language of the age, and as open source requires more and more human nature”，我知道那天你玩嗨了，也真的是收了好一波存在感。 说这个并不是想怪你，其实真的没关系，我看得到因为这次玩嗨后，对后续的学习你多了些许热情。有的时候是需要用一些东西让自己找到它的用处，你才会真的用下去，这是一个自己释放的窗口。但是你要知道你是在做什么，因为什么在做，这就够了。 既然我们是在说“共同成长”，那我们再来聊聊战友好吗？ 我猜你最想和我聊的一定是你们的教练对吗？我记得有一次你差点就放弃了，应该是Day11，那天你的SSL一直出问题，怎么都解决不了，你知道如果这个问题解决不了后面的作业基本上就都完不成了。当时猜测了很多种问题也尝试了多种方法，你甚至都想过要重装系统。我知道你可能最后都已经无奈甚至破罐破摔了，可是教练没有放弃，他帮你解决了。最后的问题是Anacanda自带的Python编译器启动不了系统的 SSL。一切的一切事后说起来都是这样的云淡风轻，但我相信看到这里你一定能回想的起来当时复杂的心情。 这件事情我知道是你记得最深刻的，但是还有一个事情，我觉得你不应该忘记。day10，那天需要通过pip安装jieba这个第三方库，最终你是通过issue上找到战友给出的方法解决的。我知道当时战友的issue让你多少有点惭愧，因为你发现一直标榜学习能力的你，在遇到这个问题的时候竟然没有做进一步的分析，甚至你都没有了解过pip是什么，就张口发文。你明白这种做法叫“索取”，没有人有义务被你索取，也许我说的重了点，但仅仅是想提醒一下你 孤独的旅程在14天的旅程结束后，你便开始了另一个旅途，这段旅途多少有些孤独，但是它却给到你带来了一个惊喜：让你更多的体会到计划和完整性的重要性 当时你计划用一个月的时间读完笑来老师的《自学是一门手艺》。我看的到，开始你是比较随性的，并没有对自己的计划进行分解。因为之前读书一直如此，以将书本的知识运用到生活中为目标而并非速度。 但是很快你就发现这样不行，太过随意让自己丧失了目标。因为10天过去了，你却没有太多的进展，其实常常并不是自己没有时间，而是一种拖延和懒惰造成的。忘记是因为什么了，也不知道是不是巧合，当时的你竟然想到了一个历史事件，让你为之一惊： 那是在1911年的时候了。当时世界上还有一个地方没有人去过，它是最后一个大洲 —— 南极。 当时有两个竞争团队都希望最先到达那里。其中一个是挪威的阿蒙森团队，总共5人；另一个是北欧的莫斯特团队，17人。两个团队基本都是在1911年10月在南极圈外围做好了准备，但两个多月后也就是1911年12月15日，阿蒙森团队率先到达了南极点并在21个月后回到了原来的基地完成了这次探险。 而莫斯特团队不仅仅晚到了。最后也恰恰因为晚了，回去的路上天气非常差，路上遇到越来越多的困难，不断地有人掉队，最终全军覆没。队长莫斯特和另外两个队员冻死在了离他们最后一个储藏装备的地方大概10英里的位置。他们付出了生命的代价。 在后来通过他们的日记中分析得知，阿蒙森团队之所以可以胜利有很多原因。包括充沛的物资、充分的调研、对困难有足够的预料。但最重要的是 ———— 他们有一个策略的区别： 阿蒙森团队做了一个有富余量的计划，并坚持按照计划完成。即，不管天气好坏，团队坚持每天前进大概30公里 莫斯特团队比较随心所欲，天气好就走的非常猛，大家走的非常多，可能有40-50公里甚至60公里，但天气不好的时候，暴风雪的时候，他们就谁在帐篷里，吃点儿东西，诅咒恶劣的天气，希望尽快转晴 其实你明白，也许到今天我们已经不需要为没有达成付出生命的代价，但是这个经验教训依然值得借鉴 因为那天的思考，你开始为这个一个月的计划进行分解。当时你先买了糖果上笑来老师那个《自学是门手艺》的音频，了解了一下每一章的难度和目标，然后试读了两天看看自己的时间花销。最后在保障自己能理解的情况下，决定前两章以每天两节的内容阅读，特殊章节比如“字符串”一天只读一章。对于第三章的内容，每天一章完成。 最终，恭喜你，终于在一个月的时间点内完成了计划 恩，好像漏了点什么。其实中间还有一个插曲对吧？ 当时是看到第三章了，在看到“拆解”之后，你多少觉得后面都是“鸡汤”了，就把节奏放缓了，同MIT 的Python课程一起学习了。 我想现在的你一定和庆幸，当时那个傻叉的自己仅仅是放缓了进度，而不是完全略过了。因为在读完后你明白： 读完才是最重要的 《自学是一门手艺》给到一个完整的心里建设，这对于后面的学习远比 “硬知识” 要重要 ———— 从最开始的时候老师告诉你它并不难学会，往后给到一些学习的方法和原则，比如耐心和刻意思考。再往后会给到达到一定程度的时候会遇到的坑，比如“装权威”。最后，基于完整性特质，引出了全栈工程师，告诉我们全面的路还有很长。而且人生很长，不必惊慌 阶段性总结前面说了很多我们在这个过程中的感触和发现，最后还是要回归这封信的主题，一起来做一点抽象，进而总结这个阶段的收获 我想一定很惊讶，为什么竟然把学习MIT的Python课的过程略过去了。其实并没有。 在我看来 MIT的Python课更像是一个引爆点，它让你对 “计划” 的理解更加具象化，所以它应该是这个总结的一部分。 为什么这么说呢？首先因为这个过程有两个特点： MIT的Python课虽然依然是自学，但有了一个社群，在这里大家会每天打卡，这个多了一个好处就是，当你看到别人打卡的时候你会不自觉的有一种代入感，不太容易被懒惰或者拖延所干扰 但同时也带来了一个坏处，就是每个人都会有自己的发现和自己的想法，你很容易被带跑偏甚至陷入一种迷茫和焦虑 另外，也恰恰是两个特点，让你兴奋过也纠结过迷茫过。最终，使你清楚的认识到一定要自己动手制定一个富有余量的计划，并执拗地执行它 这个里面有三个重点：自己动手、富有余量、执拗地执行 为什么要自己动手为什么一定要自己动手，难道别人的计划不能直接用吗？当然不是不可以，但不是这里就是那里总会有些太合适，以至于最终的效果就是没有自己动手做的好。这里至少有两个原因： 1.每个人的起点多少有些差别 起点的细微差别，它会直接导致在学习同样的内容的时候花费差异的时间。你肯定明白，从 MIT 的 Python 课程来说，至少会有两个明显的起点差别：编程和英语 就拿自己来说，我的英语水平可以说真心烂，英语4级而且毕业后就再没用过，而编程水平多少还好一些。在整个过程中我就会发现，在两个地方是我最耗费时间的，一个是阅读 PDF 的时候需要查单词理解意思，另一个就是在看视频的时候特别是第一遍看视频的时候有些翻译总觉得不对我就需要去查单词去理解它。 同时，我也知道在一起学的小伙伴中已经有是翻译的小伙伴了，显然我们因为同样的东西花费的时间就会完全不一样。当然你明白这个没必要气馁也无需害怕，每个人都是从什么都不会走过来的，这只是在填自己之前坑而已，反正或早或晚总归要填的 当然起点的差别除了这两个显而易见的差别外，还会有很多隐性的难以直接体现出来的差别，比如思考能力、理解能力等。这些都会间接的导致我们在学习同样的内容的时候花费差异的时间 所以，起点的差别虽然不一定很大，但是多少还是有的。直接把别人的计划拿过来反正就会有些不舒服 2.每个人的时间预算很难相同 什么叫时间预算？就是你每天最少可以在这件事件上花费多少时间，并且可以持续多久 其实在脱离的学校后，每个人的职业、社会身份、文化习俗的差异，都会对他的时间花销产生或多或少的影响，以至于每个人的时间花销会有所差异，最终落实到某个事情少的的花销，还和个人的价值观，以及对这件事情的重视程度相关，最终很难相同 就拿职业来说，按照《中华人民共和国职业分类大典》中的内容，我国职业归为8个大类，66个中类，413个小类，1838个细类。单单这一个维度上可能就是存在一个巨大的差别，哪怕由于社群的属性使得某些职业的群体会更多，但再加上其他维度后，差异依然是巨大的 除此之外，还有一个 最重要 的原因：自学是我们自己的事情 什么叫富有余量所谓的富有余量，指的是计划中所花费的时间，比你可以给到的预算时间再少一些 其中 预算时间 - 计划时间 所剩下的称之为 “预留时间” ，类似于工程中的 “预留金” 一样。它的首要功能当然是应对风险，应对什么风险呢？两种： 临时事件导致的 “预算时间” 不足 由于自己的疏忽和遗漏，在看到别的小伙伴发现相关内容时，返工的时间 但是我觉得另一种功能更为重要： 提供一个完善自己的计划的可能性 因为自学的方法这个事情，总是需要也总会不断完善的。可能你没想到或者没有发现的内容和方法会被别的小伙伴提出来。比如在学习 MIT 的 Python 课的过程中，就有小伙伴提出应该看 PDF 的方法，也有小伙伴提出 MIT 有原版书应该和课程一起学习，这个时候 “预留时间” 就起到了作用 其实完善计划是很耗费时间的，真的不是随随便便的并入就可以的。至少你要比较相似度、考虑时间的充裕度、并考察效果后，再决定是不是并入你的计划 在学习 MIT 的 Python 课程的时候，当小伙伴提出上面的方法时，我首先比较了原版书和课程本身的相似度。原版书一共有24个章节，前10个章节和课程相对应，可以部分匹配。之后我考虑了时间的充裕度，按照我的速度将原版书加入时间会拉长两倍超出时间预算，而将 PDF 阅读纳入学习中时间消耗并不多。最后我通过两节课程的学习考察了将 PDF 阅读后的效果，发现确实有明显的加强。于是将 PDF 阅读纳入计划中，并确定每节课程的学习方法：看一遍视频 - 读一遍 PDF - 再看一遍视频 也许你会问我，为什么不能不留 “预留时间” ，需要并入的时候改计划不是也可以？也不是不可以，就是差别会很大。如果你改了计划，由于时间的限制你可能会需要调整节奏甚至舍弃一部分内容。你甚至还要为此比较一下两种不同的情况下那种效率更高，然后进一步拖后计划 所以说，富有余量 很重要，它会在不太影响内容和节奏的情况下，给你提供一个完善自己计划的可能性 尽量保障计划的完整性1.优先保障计划可以 “通读” 学习内容我想我们不用着急一次把所有的内容都搞清楚，也不用着急把连带的内容都看完。我们应该优先 “通读” 学习内容： 《自学是一门手艺》中笑来老师说：读不懂也要读完 《通往财富自由之路》中笑来老师说：读书要先看目录 甚至我的语文老师也教导过我：一定要先通读古文再拆解 其实这些表达的都是一个意思，当你 “通读” 完内容之后，你就会有一个大体的轮廓。你会知道谁和谁之间有关系，你会知道每个部分大概是怎么样一个内容。这样学习第二遍的时候就会更容易理解。当然真正的好书和好文章也不是一遍就可以读完的（这也是我开始第二遍读《自学是一门手艺》才知道的，好书就是一本宝藏，至少参考文献都够你挖好久） 2.尽量保障计划覆盖最小单元如果在一个连续的计划内，无法 “通读” 学习内容，那么退而求其次 —— 尽量保障计划覆盖最小单元 什么叫最小单元？就是可以拆分的相对独立的最小学习模块。一个最小单元有着内部内容的连贯性和相关性 而计划覆盖最小单元，强调的是连续性，这是因为考虑了记忆的特性，这样可以最大限度的降低我们学习和理解成本的方法。我们知道按照 “艾宾浩斯记忆遗忘曲线” 一天之后我们记忆的内容仅会剩余25%，如果隔了更久将会更少。即便我们有所记录或者总结，还是会有很多细节的东西我们会忘记。计划覆盖最小单元，就是针对连续性或相关性的内容最大限度的降低理解和学习成本 比如 MIT 课程 我将它分为了10个最小模块，1-7分别是7个模块讲了7个独立的内容，8-9是一个模块讲类及面向对象编程，10-11是一个模块讲效率问题，12是一个模块更偏向于算法 假设你先制定了连续3天的一个学习计划完成了 MIT 的第一节课程，中间停了两天，然后又制定了一个5天的学习计划完成了 MIT 的第二节课程和第三节的一部分。那么先制定的学习计划是满足覆盖最小单元的，而后制定的学习计划虽然覆盖了第二节这个最小单元，却没有完全覆盖第三节这个最小单元，所以是不满足的 另外，除上面的两点外，最重要的是：一定要做好整理和记录。因为不管是“通读”还是“覆盖最小单元”,都要面对一个问题，就是记忆的流失和不确定。而整理和记录是最好的应对方法 执拗地执行其实前面我们聊明白了，“执拗地执行” 就是自然而然的事情，原因无非两点： 既然已经想清楚了，并作出了一个适合自己的富有余量的计划，有什么理由不执拗地执行呢？ 如果是因为懒或者怕麻烦，那就算了吧。就像笑来老师说的 “活着就挺麻烦的” 最后，还是想说，很幸运。虽然未来自学的路还很长，但我们却都跌跌撞撞的走好了这“第一步”，愿未来一直有你并肩前行 祝好 李浩天 写于 2019 年 7 月 8 日]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100065-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901100065-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：brian学号：1901100065 工作背景大型互联网公司游戏策划 自我介绍科技产品爱好者，生活黑客，两个娃的爹。 学习原因 工作中有大量产品和用户数据分析的场景，希望能够在分析方法、思路以及效率上有所提高。 希望能在生活里的决策中用数据分析的方式指导决策，比如购房、和各类投资场景 目前学习阶段 Python自学训练营马上毕业 之前有少量编程经验，可以在excel里写简单的vba程序，在mac各类效率工具中编写脚本。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>游戏策划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-自学训练营-MIT60001]]></title>
    <url>%2Funcategorized%2F1901060005-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901060005 学习内容：MIT 30天打卡 学习用时：14.5小时(1-6) + 46.5小时(7-30) 学习笔记第一天学习内容：看唐总总推荐链接的视频，感谢自学营没有忘记我们。看第一节课视频40 分钟。 学习心得： 1.刚打开视频，有种崩溃的感觉，完全不知所云，看到十分钟左右还是蒙蒙的状态， 视频起到了很好的催眠效果，看视频的过程中几乎要睡着了。还好为克服惰性选择在 星巴克，喝了一口咖啡提提神，慢慢的看到简单的程序语言有点点熟悉的感觉了，能 够跟着视频听懂一些内容，原来的睡意也没有了，不错的感觉。 2.通过视频学习，对于老师讲到的计算机运算能力很快，但是它什么都不知道，如果 没有给他指令，它什么也做不了，如果我们想让计算机输出“X”就需自己先知道怎样 才能够得到它，并转化机器语言输入计算机。感觉这样的表述特别清楚，学习机器语言就是学习规范自己的逻辑思维的过程。 3.学习语言的关键动作就是 练习。 4.任何学习都是有一个过程： 知行合一 第二天 视频学习内容： 1.字符串的基本概念和简单操作 2.学习了Python的分支、迭代、循环的表达方式。 学习心得： 1.又加深了对字符串的概念和基本操作的理解。 2.if…elif…的表达方式更精简了语言的条件、分支的表述。 3.加深了对for和 while两个循环的理解， for循环和while循环，两者的相同点在于都能循环做一件重复的事情；不同点在于， for循环是在序列穷尽时停止，while循环是在条件不成立时停止。 第三天学习内容：1.学习视频两遍用时1.5小时2.学习了字符串的操作，字符串只能被切分，不可更改。3.新学习到字符串可以简单被反向遍历，以前竟然没有想象过这个问题。4.学习了三种算法：guess-and-check,approximate solutions,bisection method 学习心得：自学营结束后，自己又是不是的学习笑来老师的《自学是门手艺》，也有上机练习编程，虽然没有熟练，不过可以编写简单的程序，通过MIT自学营的唤醒，对于Python语言的熟悉度又加强了。主要是在自学的过程中提升了自己的自信心，以前从来没想象自己可以编程，那是遥不可及的事。通过学习感觉到了只要自己要做，并且持续的坚持、践行，就一定会有收获。相信只要学习就一定会产生时间的复利。在学习营里有任务的学习，有同学和老师们的互相砥砺，惰性减少，效率提升，有组织的感觉真好。 第四天 学习时长2小时学习内容： 1.复习笑来老师《自学是门手艺》Part.1.E.2.values-and-their-operators部分。2.学习网上前辈们的技术博客，主要也是学习数值的类型和转换函数。 学习心得：1.基本的三种数据类型： 布尔值（Boolean Value) 数字（Numbers）：整数（Int）、浮点数（Float）、复数（Complex Numbers） 字符串（Strings 重点是有读到了笑来老师书里的一句话： 运算的一个默认法则就是，通常情况下应该是相同类型的值才能相互运算。 这句话自所以是重点，关键它是一个默认法则，也就是通常情况的运算都是遵循这样的法则运行。那么有没有例外呢？自己也在网上搜索了相关信息好像没有不同类型的数值进行运算。不同类型值之间要进行运算就需要进行数值转换，那么转换的函数都有哪些呢？2.数值转换的函数： 1234567891011121314int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 3.了解并加深了理解不同数值的操作符。 第五天 学习时长2.5小时学习内容： 1.学习第四天视频内容。2.学习定义函数和函数内容编写。 学习心得：1.视频中的编程内容基本都能够理解，不过自己在读写甚至是编写的时候就感受到了在练中学，对概念的理解是相对容易。2.比如Python中的函数，自己最初的理解就是一个能够实现某一功能的小段程序。 函数能提高应用的模块性，和代码的重复利用率。 3.函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义一个局部变量。如果要在函数中给全局变量赋值，需要用global关键字声明 第六天 学习时长5小时学习内容： 1.笑来老师《自学是门手艺》递归函数部分。2.视频作业练习。3.学习了变量的局部范围和全局范围 学习心得：1.学习了递归函数三原则并反复测试递归函数： 1).根据定义，递归函数必须在内部调用自己；2).必须设定一个退出条件；3).递归过程中必须能够逐步达到退出条件…… 2.用循环方法和递归函数两种方法计算数值的求和。 递归函数法 123456def sum1(num): if num ==1: return 1 else: return num+sum1(num-1)print(sum1(5)) 循环法 123456def sum1(num): a=0 for i in range(1,num+1): a+=i return aprint(sum1(5)) 条条大道通罗马，现在的感觉哪条大道修起来都不容易。程序思维是学习的重点，虽然进展缓慢，还是要着实用功。 第七天 学习时长3小时学习内容： 1.教学视频及作业练习2.学习元组•列表3.一系列列表的操作函数 学习心得： append,extend，remove,del,pop 等函数都会改变列表。 12345678L1=["bacon","eggs"]L2=["toast","jam"]brunch=L1L1.append("juice")brunch.extend(L2)print(brunch)print(L1)print(L2) 结果 123&gt; [&apos;bacon&apos;, &apos;eggs&apos;, &apos;juice&apos;, &apos;toast&apos;, &apos;jam&apos;][&apos;bacon&apos;, &apos;eggs&apos;, &apos;juice&apos;, &apos;toast&apos;, &apos;jam&apos;][&apos;toast&apos;, &apos;jam&apos;] join将 容器对象 拆分并以指定的字符将列表内的元素(element)连接起来，返回字符串（注：容器对象内的元素须为字符类型）。 split以指定的字符将字符串分割为单个元素(字符类型)并加入list中，返回一个List。 sorted(L) 返回一个排序后的L，不改变原始的L； L.sort() 是对原始的L进行操作，调用后原始的L会改变，没有返回值。L.reverse() 倒序排列并改变列表。 remove()不能用于循环删除。 x = [‘a’, ‘b’, ‘c’, ‘d’]y = [‘b’, ‘c’]for i in x:if i in y: x.remove(i)print x result：[‘a’, ‘c’, ‘d’] 第八天 学习时长3小时学习内容： 1.第五天学习资料中“lec5_tuples_lists.py”文件，运行里面的代码。 学习心得： 元组与元组可以进行相加操作，元组也可以迭代。 t=’python’b=(6,7,8)c=b+(t[1],)print(c) (6, 7, 8, ‘y’) 没有搞懂为什么这个函数变量无法调取外部数值 1234567891011121314def sum_elem_method1(L): total = 0 for i in range(len(L)): total += L[i] return total def sum_elem_method2(L): total = 0 for i in L: total += i return total print(sum_elem_method1([1,2,3,4]))print(sum_elem_method2([1,2,3,4])) 错误提示： unindent does not match any outer indentation level (, line 3) 问题解决：total缩进有问题 第九天 学习时长4小时学习内容： 1.函数的返回值及函数调用间的关联2.字符串的格式化方法 学习心得： 函数无论是否有返回值，都是可以被调用的，没有返回值用print打印函数返回结果是None，有返回值的时候就可以用print显示函数的返回结果。 例如： 123456789def say_hi(*names, greeting='Hello', capitalized=False): for name in names: if capitalized: name = name.capitalize() print(f'&#123;greeting&#125;, &#123;name&#125;!')say_hi('tome','jack')print('-'*20)print(say_hi('tome','jack')) 终端运行结果： 123456&gt; Hello, tome!Hello, jack! --------------------&gt; Hello, tome!Hello, jack!None 字符串格式化方法主要有三种：%格式化 ， str.format()和f-Strings。 %格式化操作容易表现出各种问题，导致许多常见错误（例如无法正确显示元组和字典）。 python中用%代表格式符，表示格式化操作，常用的操作有%s,%d,%r等.%r用rper()方法处理对象%s用str()方法处理对象%d十进制整数表示 使用较新的格式化字符串文字或 str.format() 可以有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的格式化文本方法。它使用普通函数调用语法，并且可以通过 format() 方法为对象进行扩展。使用 str.format() 时，替换字段用大括号进行标记。 str.fotmat()在处理多个参数和更长的字符串时仍然可能非常冗长。 f-Strings，它可以使得字符串格式化更加容易。f-strings 是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。 12345678910111213141516171819202122name = "hoxis"age = 18someone="hello, %s. you are %s ?" %(name, age)print(someone)print()person = &#123;"name":"hoxis","age":18&#125;is_person="hello, &#123;name&#125;. you are &#123;age&#125;?".format(**person)print(is_person)print()name = 'hoxis'age = 18status = 'Python'message =[f'hi &#123;name&#125;.'f'you a &#123;age&#125;.'f'you are learning &#123;status&#125;.']print(message) 对应结果： hello, hoxis. you are 18 ? hello, hoxis. you are 18? [‘hi hoxis.you a 18.you are learning Python.’] 第十天 学习时长4小时学习内容： 1.学习了列表操作中append()，extend(),insert()不同函数之间的区别，以及pop()和remove()的区别。 学习心得： 看到群里同学们在讨论append()，extend()的异同，这是自己没有留意到点，顺便做了一点延申学习。 append(object) 是将一个对象作为一个整体添加到列表中，添加后的列表比原列表多一个元素(会改变原列表)，该函数的参数可以是任何类型的对象，该函数没有返回值extend(iterable) 是将一个可迭代对象中的每个元素逐个地添加到列表中，可迭代对象中有几个元素，添加后的列表就比原列表多几个元素，该函数的参数必须是可迭代的对象，改函数没有返回值insert（object） 方法是指在某个特定位置前面增加一个数据项。 1234a_list=[1,2,3]b_list=[4,5,6]a_list.append(b_list)print(a_list) [1, 2, 3, [4, 5, 6]] 第十一天 学习时长5小时学习内容： 看了一遍多的视频。 学习递归函数、编写并运行。学习心得：1234567891011def printMove(fr, to): print('move from ' + str(fr) + ' to ' + str(to))def Towers(n, fr, to, spare): if n == 1: printMove(fr, to) else: Towers(n-1, fr, spare, to) Towers(1, fr, to, spare) Towers(n-1, spare, to, fr)Towers(3,1,2,3) 1234567move from 1 to 2move from 1 to 3move from 2 to 3move from 1 to 2move from 3 to 1move from 3 to 2move from 1 to 2 感觉递归函数特别牛，如此聪明的代码，能看懂但是想不出，满受刺激。 兔子繁殖的算法让自己头晕，感觉会编程的都是数学家。化繁为简需要的智慧。 第十二天 学习时长2小时学习内容： 学习群里优秀的打卡作业 学习lec6_recursion_dictionaries.py一个程序学习心得： 套用两个自定义函数的自定义函数感觉逻辑上都难理解。还是先从实用、简单的小程序入手，循序渐进。 第十三天 学习时长3小时学习内容： 学习编程书本中的基础概念及使用。 学习for循环和while循环。学习心得： 两种循环方法，询问用户显示哪个数的乘法表。 123456789101112131415i=int(input("Which multiplication table would you like:"))print ("Here's your table:")for j in range(1,11): print("%d x %d = %2d"%(i,j,i*j))i=int(input("Which multiplication table would you like:"))print ("Here's your table:")j=0while j &lt;=10 : if j &gt;=0: j+=1 print("%d x %d = %2d"%(i,j,i*j)) else: break #print() 运行结果 : 12345678910111213Which multiplication table would you like:5Here&apos;s your table:5 x 1 = 55 x 2 = 105 x 3 = 155 x 4 = 205 x 5 = 255 x 6 = 305 x 7 = 355 x 8 = 405 x 9 = 455 x 10 = 505 x 11 = 55 for循环（计数循环） range()函数–计数循环的一个捷径。 while循环（条件循环） 用continue跳到下一次迭代 用break跳出循环 第十四天 学习时长2小时学习内容： 学习MIT视频两遍 运行、验证代码学习心得： 学习视频就当练习英语了，内容及程序还是要时间慢慢消化，不断地验证吸收。 第十五天 学习时长4小时学习内容： MIT练习题 字符串格式化的几种方法，编写九九乘法表。学习心得： 字符串几种常用的方法：%操作符，f-Strings，str.format str.format 1234for i in range(9,0,-1): for j in range(i,0,-1): print('&#123;&#125;x&#123;&#125;=&#123;&#125;'.format(i,j,i*j),end=' ') print() 1234567899x9=81 9x8=72 9x7=63 9x6=54 9x5=45 9x4=36 9x3=27 9x2=18 9x1=98x8=64 8x7=56 8x6=48 8x5=40 8x4=32 8x3=24 8x2=16 8x1=87x7=49 7x6=42 7x5=35 7x4=28 7x3=21 7x2=14 7x1=76x6=36 6x5=30 6x4=24 6x3=18 6x2=12 6x1=65x5=25 5x4=20 5x3=15 5x2=10 5x1=54x4=16 4x3=12 4x2=8 4x1=43x3=9 3x2=6 3x1=32x2=4 2x1=21x1=1 %操作符 1234for i in range(1,10): for j in range(1,i+1): print('%dx%d=%2d'%(i,j,i*j),end=' ') print() 1234567891x1= 12x1= 2 2x2= 43x1= 3 3x2= 6 3x3= 94x1= 4 4x2= 8 4x3=12 4x4=165x1= 5 5x2=10 5x3=15 5x4=20 5x5=256x1= 6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=367x1= 7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=498x1= 8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=649x1= 9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81 f-strtings 1234for i in range(1,10): for j in range(1,i+1): print(f'&#123;i&#125;x&#123;j&#125;=&#123;i*j&#125;',end=' ') print() 第十六天 学习时长40分钟学习内容： 笑来老师的《自学是门手艺》“保存到文件的函数”部分学习心得： 事情忙起来都没时间学习，当然也和惰性有关，没有及时投入学习。当有突发情况出现只有见缝插针的进行学习并完成日记。 学习了函数保存文件里作为模块方便调用，并温习了函数调用的方法。 第十七天 学习时长3小时学习内容： 笑来老师的《自学是门手艺》“值及其相应的运算”部分 学习lec7_debug_except.py中的程序学习心得： lec7_debug_except.py中的程序对自己来说还是要再花时间消化. 定义素数列表函数这里就花费了很多时间，刚开始都没有理解程序的逻辑。 学习别人的程序前首先要看看注释，能比较快速的理解函数要实现的功能。 第十九天 学习时长2小时学习内容： 学习了解“对象”的概念:对象=属性+方法 可以对它们做什么（动作）。 如何描述（属性或特性）。 学习心得： 先定义对象，像什么，会做什么。就如先画一张图纸确定要建造的实体是什么，能干什么。 第20天 学习时长40分钟学习内容： 学习lec8.classes.py里面的程序学习心得： 没有很好的理解这部分内容，需要加深学习这部分，争取能有点点突破。 第21天 学习时长50分钟学习内容： 学习“类”与“对象”的概念学习心得： class后面紧接着是类名，类名通常是大写开头的单词（例如：Teacher），紧接着是(object)，表示该类是从哪个类继承下来的. 注意到init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 第22天 学习时长3小时学习内容： 学习“对象”，加深理解属性，方法及实例。学习心得： 对象=属性+方法 属性相当于变量，只不过是在对象中的变量。它可以显示，可以赋值，可以给常规变量（不是对象的变量）赋值，可以给其他对象的属性赋值。 对象就是将一个产品从无到有的一个过程，定义类就相当于给一个即将建造的产品命名，然后通过属性和方法告诉大家这个产品是什么，什么形状、颜色、大小、重量等等属性，它可以做什么，可以怎样操作等等。 比如建房子，属性和方法就是相当于为要建的房子画了一个图纸，只要按图施工就可以建造出图纸上的房子。实例就是开始按照图纸建造房子，一个图纸可以建造很多房子。 123456789101112131415161718192021class Door(): "定义类-门" def __init__(self,size,color,type): "初始化门的属性" self.size = size self.color = color self.type = type def open(self): "门操作的方法" print("打开这个宽%scm颜色%s的%s门" %(self.size,self.color,self.type)) def off(self): "门操作的方法" print("关闭这个宽%scm颜色%s的%s门" %(self.size,self.color,self.type))door1 = Door('90','red','木门') #门的实例化1door1.open()door2 = Door('120','white','铝合金')#门的实例化2door2.off() 打开这个宽90cm颜色red的木门门关闭这个宽120cm颜色white的铝合金门 第23天 学习时长50分钟学习内容： 对象实例，数据隐藏学习心得： 构建一个对象首先要定义，可以初始化属性，可操作的方法，创建实例。虽然大概流程了解了，要使用好对象还是要在代码上多下功夫，既要不断地熟练基本操作，又要不断的理顺自己的逻辑思维能力。在顺利程序的过程中也是不断的顺利自己思维里的逻辑，是一个一举两得学习。 对象中的数据（属性）可以被查看和修改，不过建立一个方法可以同时调整两个及以上的属性，还有就是可以避免很多无效的操作。 第24天 学习时长30分钟学习内容： 了解学习对象的两个重要的方面：多态。 学习了两个多态程序。学习心得： 多态就是在一个对象中可以有两个或者多个相同的方法，它们可以有不同的行为。 同时再强化下方法，对象的方法就是可以调用这些代码做什么事。方法就是对象中的函数。 概念的理解是学习效率的关键，对于重要概念要反复的学习、复习、敲代码践行。 第25天 学习时长50分钟学习内容： 对象的继承学习心得： 继承就像孩子从长辈继承了一些东西，比如样貌、皮肤、发质等等，也可以是钱财。 对象的编程中，类可以从其他类继承属性和方法，就形成一个“家族”以共享相同的属性和方法。 1234567891011121314151617181920class Person(object): def __init__(self,name,sex): self.name = name self.sex = sex def print_title(self): if self.sex == "male": print("man") elif self.sex == "female": print("woman") class Child(Person): # **Child 继承 Person** pass May = Child("May","female")Peter = Person("Peter","male") print(May.name,May.sex,Peter.name,Peter.sex) # 子类继承父类方法及属性May.print_title()Peter.print_title() 第26天 学习时长 30分钟学习内容： 对象现实应用学习心得：明天继续完成 123456789101112131415class BankAccount: def __init__(self ,account,name,balance): self.account=account self.name=name self.balance=balance def save_money(self, money): self.balance += money def draw_money(self,money): if self.balance&gt;=money: self.balance-=money print("取款金额：&#123;&#125; 余额：&#123;&#125;".format(money,self.balance)) else : print("余额不足") 第27天 学习时长 50分钟学习内容： 对象现实应用学习心得：123456789101112131415161718192021222324252627class BankAccount: def __init__(self ,account,name,balance): self.account=account self.name=name self.balance=balance def save_money(self, money): self.balance += money def draw_money(self,money): if self.balance&gt;=money: self.balance-=money print("取款金额：&#123;&#125; 余额：&#123;&#125;".format(money,self.balance)) else : print("余额不足") def check_balance(self): print("账号：&#123;&#125; 户名：&#123;&#125; 余额：&#123;&#125;".format(self.account,self.name,self.balance))bankat=BankAccount(123456,"lili",3200)bankat1=BankAccount(123489,"王文",1000)bankat.save_money(2800)bankat.draw_money(1200)bankat1.save_money(890)bankat1.draw_money(1000)bankat.check_balance()bankat1.check_balance() 取款金额：1200 余额：4800取款金额：1000 余额：890账号：123456 户名：lili 余额：4800账号：123489 户名：王文 余额：890 第28天 学习时长60分钟学习内容： 使用pygame绘制圆形，矩形。学习心得： 在学习的路上不会孤单，有问题先在网络上查找解决问题的办法，有无数的先行者已经把踩过的坑都做了解决攻略。学习中最需要的是克服自己的浮躁，有问题的时候就是提升自己的时候，无论知识还是情绪。 学习python基础的概念、知识点之后，可以借助第三方库解决很多实际问题，这样语言就越来越贴近工作和生活了。 123456789101112import pygame,syspygame.init()screen = pygame.display.set_mode([640,480])screen.fill([255,255,255])pygame.draw.circle(screen,[255,0,0],[320,160],60,0)pygame.display.flip()running=Truewhile running: for event in pygame.event.get(): if event.type==pygame.QUIT: running=Falsepygame.quit() 第29天 学习时长70分钟学习内容： 学习了一部分程序复杂度分析（大O表示法）。学习心得： 看了Lecture10部分视频，云里雾里，通过网络资料了解、学习程序复杂度分析。算法通过时间复杂度和空间复杂度来评价一个程序的好坏，衡量算法的运行时间有三种方法： 基准评价、统计指令，以及复杂度分析（大O表示法）。 空间复杂度和时间复杂度，可以作为选择数据类型的评判标准之一。 对于一个程序来说，编程语言提供了最基础的类型实现，例如python里面的str，int，float，list，tuple等，在表达一个数据结构的时候，就有各种选择，可以选择不同的方式，而当你选定了数据结构，那么你程序最基本的运行时间就大概已经定型。 不同数据结构复杂度连接分享。 https://www.cnblogs.com/yueyun00/p/10246251.html 第30天 学习时长60分钟学习内容： 使用pygame随即绘制100个矩形。学习心得： 在脚本上随便修改矩形颜色，底板颜色，随机生成100个矩形图案相互叠加还是蛮好玩。 时间和坚持会越来越了解、理解一门语言，同时这门语言是未来的趋势，是技能、是手艺、是逻辑训练工具、是与年轻人交流的工具甚至可以成为发展兴趣的工具（瞬间感觉这门语言很强大^ _ ^）。 坚持打卡30天，过程中不断的挑战、突破，时间及惰性，虽然还有太多不足，而这也是前行的动力。 1234567891011121314151617import pygame,randompygame.init()#初始化pygamescreen = pygame.display.set_mode([640,480])#设置显示幕布的宽和高screen.fill([255,255,255])#幕布填充白色for i in range(100): width = random.randint(0,250) height = random.randint(0,100) top = random.randint(0,400) left = random.randint(0,500) pygame.draw.rect(screen,[0,0,0],[left,top,width,height],1)pygame.display.flip()running = Truewhile running: for event in pygame.event.get(): if event.type == pygame.QUIT: running = Falsepygame.quit()]]></content>
  </entry>
  <entry>
    <title><![CDATA[1901050017-今年是自学编程年，我将用这个杠杆来撬起我的未来]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901050017-%E4%BB%8A%E5%B9%B4%E6%98%AF%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B%E5%B9%B4%EF%BC%8C%E6%88%91%E5%B0%86%E7%94%A8%E8%BF%99%E4%B8%AA%E6%9D%A0%E6%9D%86%E6%9D%A5%E6%92%AC%E8%B5%B7%E6%88%91%E7%9A%84%E6%9C%AA%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[阿基米德曾经说过，给我一个杠杆我能撬起整个地球。 硅谷投资人Naval说： Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep. Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.Apply specific knowledge, with leverage, and eventually you will get what you deserve. Specific knowledge can’t be taught, but can be learned. Knowledge that gets you paid. Identify your strengths and apply them Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media). 我一直想和这个世界有更深的连接，而不仅仅是做一个时代的局外人。而作为年近40的人，想要更深的连接只有通过“杠杆”工具了。在之前的几年，我通过自学，已经拥有了两个“杠杆”。 杠杆1: 自学excel vba，让工作流程半自动化，精确结果，效率提高 我曾因为恐惧，恐惧不能跟上时代，这个念头在我脑子里盘踞了很久，我不禁自问，如果我这时候没有工作了，我有拿的出手的特长吗？我会脱离人群吗？ 我的工作是中学教务处老师，相对“稳定”。但内心深层的焦虑和危机感还是占据了我的大脑，看看周围，几乎都是心态半退休的人们，至今我都记得那时的感觉：焦躁不安，束手无策。我只知道我不想再当那种出了大学门就再也没升级过知识的人。左思右想，我决定从小事做起。先把我的工作升级一下，至少这是我力所能及的。我的主要工作是安排课表和监考，统计课时费，但一直都是半手工，半电脑输入，至于怎么改进我一点头绪都没有，问问周围的同事，她们都摇摇头，说做的挺好的呀，没有必要改。我知道我不能再求助他们了，我转向网上，开始逛办公软件的论坛，就这么一点一点的，从一个公式到vba，我用了两个星期的时间，把课时费统计表做成了半自动化输出，课表和监考表做成了半自动生成，当测试结果完全符合我的期望时，有一种从原始社会进化到现代社会的感觉。至于刚开始的恐惧，早就随着进化一点一点地消失了。 杠杆2: 自学英语，和现代先进的文化产生了更直接的连接 这次得到人生杠杆的原因是紧迫，这个紧迫呢，是由于孩子的原因。我的大女儿按计划去国外上学，国外各种文件、邮件纷至沓来，而家中无一人看得懂。思来想去，我决定学英语，想着，将来女儿需要我去国外陪她的时候，我能顶得住。人啊，一旦尝过甜头，就不肯停下来了，学习也是如此，尝到过自学的快乐，就总会找机会再尝试的。这次我不是没头苍蝇似的瞎找，而是直接决定—-以“用”代“学”英语了。这个决定是因缘际会，看到了李笑来老师的《人人都能用英语》之后做出的。这也是我第一次看李笑来老师的书，虽然那时还没有来得及去研究他的背景，但是他的实践主义让我看到了学英语的希望。时间紧迫，也没做他想，就这么地，我急匆匆地踏上了第二次自学之旅。没有什么特别的开始，那时起，每天我都在办公室朗读《大空头》，车上、健身时耳机里都放着它的电子书音频,因为我记得李笑来老师在书里说过： 读一本真正感兴趣的原版书，讲的是自己正真感兴趣的话题，你不用去坚持，不用去挣扎，这时候是自己在“用”，而不是在“学”。我们关注的不是英语字句本身，而是文字承载的内容，英语只是挡在我们和内容之间的毛玻璃，时间久了，就会越磨越薄。 我知道自己对金融非常感兴趣，于是我从这方面着手，从兴趣这个点扩展到英语整个面。就这么过了一年，有一次在电影院看英语原版电影时，突然发现我都听懂了，当时的我怔住了，心跳地厉害，那时我知道英语不再是我的弱项了，而将来有一天女儿需要我去异国陪伴，我也会竭尽所能不拖后腿，替她挡风遮雨。 英语真的是和现代文明连接最快的方式。 杠杆3:编程。它可以带我活在未来 如今，编程是这个时代无须权威机构许可，就能使用的杠杆，它们是这个世界上最聪明的人创造的语言，它们是顶级思维凝聚的智慧结晶。我知道它会给我力量，来突破成长边界线。用它可以撬起我的未来，不再做时代的局外人。什么叫局外人？就好比大学文凭金贵的时代，不参加高考的人；改革开放的时代，不去当弄潮儿，反而变成下岗工人的人；地产时代，不购置房产的人；每个时代都有它的特征，现在，不会编程在我看来，就是错过了这个时代。而在更新知识如此快的编程世界，知识更新的速度比进入课本的速度快，等到学校里把它定为一门课程，等着老师来教的话，就永远学不到最新最快的编程知识了。 既然我知道了我需要掌握的技能，那我如何敲开呢？我试了读书、看视频、报网课，信心满满地开始，回头丧气地停滞。前几次自学成功的自信心被击碎了，眼看着未来已来，而我却束手无策。所以，在我看到李笑来老师的python自学训练营开班后，立刻就报名了。说实话，我当初报名，也是死马当活马医的心态，因为确实编程的学习停顿了一些日子了，苦于不能敲开门，心态已经不好了。没想到的是，最终结果是我竟然以优秀学员的成绩毕业，用6天的时间学完了14天的课程。那，我是怎么做到的呢？ 首先，自学训练营不是传统教学方式，但它是最符合编程学习的方式：没有老师教，不限地点，资料都是最新的，自己看书、思考 + 社群同学请教 + github分布式提交作业。进了自学营，不仅学会的是编程，还学会了在github上和全世界最优秀的人们（都在GitHub上）近距离接触—通过作品接触。那么github是什么呢？github是一个面向开源及私有软件项目的托管平台。github的特点，简单来说就是，代码托管，开源共享。第一点：代码托管。比如说，在你出差的时候，带了一台笔记本，想在有空的时候写写代码，但是你的代码在另一台台式电脑，这该怎么办。如果己经把代码放到github上，那只需要下载下来就可以了。那么，代码托管，并不是github特有的。github最大的亮点在于，开源共享。第二点：开源共享。第一点好处就是团队协作。一个项目分成几个模块，无论大家身在何处，都可以一人做一部分，再把自己做的部分上传到github仓库里。真正是全世界协同合作。另外一点好处是，可以借鉴别人的代码，模仿大师的杰作，在别人允许的情况下为己所用 。比如说，准备做一个项目，往往一个复杂的项目都需要把项目分成多个模块来做。这时可以上github搜与项目或者各个模块相关的代码，然后进行二次开发，省时省力，比自己纯手写代码节省很多时间成本。第三点：对于学习编程的人来说，github就是天堂。学习编程不是学语法这么简单，最关键的是要动手，学习编程讲究多看多练。github就提供了很好的学习机会。可以在github找些小项目来学，代码少，而且简单。先是看一遍，然后自己动手把这个项目重做一遍。如此一来，确确实实能够学到很多东西。gitHub于2008年4月10日正式上线。目前，其注册用户已经超过350万，拥有超过900万开发者用户。 训练营带给我的 训练营的每日作业都会迫使我主动思考，逼迫我一字一句去阅读要求，不按照要求做就会完不成作业，强制改正了我阅读不仔细的问题。 社群式学习。不是单打独斗地面对困难，‘恐惧未知’这条恶龙不会在大脑中盘旋很久，因为有教练和同学在帮助着我，即使偶尔会深陷泥沼，只要我呼喊，他们就会立刻施于援手。学习效率大大提高。 养成了阅读官方档案的习惯。这一点非常重要，每天的作业都会给出官方档案的链接，在群里大家也会互相提醒，随时巩固这个好习惯。 学会了程序员思考，遇到难点，学会把它分成一小段一小段来解决，并且用自己熟知的知识尝试类比来解释给自己听。 深刻地认识到了借鉴优秀程序员的智慧结晶是非常重要的，有质量的输出的前提是要有质量地输入，如果能看懂优质代码，并为己用，这本身就是一种进步。 千里之行，始于足下—-训练营第一天自学训练营最能反映学习中不好的习惯。 收到“自学任务清单”，开始学习。清单表达的很清楚，但真的就是我看不见它，它一直在那里。清单里要求先看参考资料，我愣是自动掠过这一步，现在想来，真的是很佩服我的大脑，就这样习惯性地怕麻烦，找捷径，试图略过一切，然后还妄想能快速完成作业。 我在卡壳以后，冷静了下来，重新从清单1开始看，耐心地看了参考资料，认真地对待每一句话，这样竟然神奇地解决了每一个问题。这次我认识到想要解决问题，还是得克服自己的毛病。在做作业时，踏踏实实。 因为习惯不好，没有阅读官方文件。在一个小到不能再小的步骤上卡壳了1个小时。 在查看社群其他人的聊天中，找到了解决方案，在第一天截止时间前完成了第一天的打卡。 好久没体会过沉浸的感觉了，就是那种猛一抬头，一个小时过去了。 第一天的学习让我认识到想要解决问题，还是得克服自己的毛病。在做作业时，要踏踏实实。 纸上得来终觉浅，绝知此事须躬行—-训练营第二天看到群里的同学都在陆续地交作业（社群学习的好处，时刻督促自己），我停掉了“自我攻击的剧情”，心里开始接受一件事，那就是遇到不会的问题时是正常的，不久的将来一定会熟练掌握的。于是，心理突破了，脑子和手并用，完成作业的速度就提上来了。再加上，我不再以借鉴代码为耻，目的就是为了学习，我再借鉴的基础上再加上自己的理解，现在已经能够写出代码的一大部分了。自主学习加同学间互助式学习，具像化了李笑来老师说的： 很多人有莫名其妙的误解，以为“自学”（self-learning)就一定是“自己独自学”（solo-learning)，殊不知，自学也需要社交。 别怕！ 啥也别怕！没什么可怕的！ 收获总结： 学会了抄代码。不再谴责自己没用，心安理得地抄了三种代码，然后运行，改写代码，最后改写出了自己的代码。 敢于调试，以前总是怕出现问题，手心冒汗，后背冒汗，脑袋发麻，如今出现问题我就搜索问题是什么意思，然后冷静地去想办法解决。 学会去github里的issues找问题答案。 读书破万卷，下笔如有神—-训练营第三天收获总结： 行之有效的方法就是大量阅读官方资料，因为是社群学习+github分布式交作业，所以可以看到很多同学的代码。学习+模仿，是我在3天时间内完成day1-6的任务的秘诀。输入有质量才是最好的进步方式。 读书不觉已春深，一寸光阴一寸金—-训练营第四天写python代码，做有用之事。在第四天，完成到了训练营day10的任务。 收获总结： 因为这几天的学习，让我深刻体会到了废寝忘食、孜孜不倦、目不转睛、聚精会神、茶饭不思的境界，心流时间可以达到3、4个小时不间断。 对阅读更是有了新的体会：一字不落的读，来回反复地读，不躲避，不放弃，迎着困难读。 对官方文档更加看重，对google也更加依赖，李笑来老师说的好： 学习任何东西，首先看官方文档或产品说明书，那些学习高手都是会先阅读官方文档的人。 能google出答案的问题，就不需要去麻烦别人.google、stackoverflow、wikipedia、youtube这都是自学人经常要去搜索的好地方。 千里之行，始于足下—-训练营第五天 眼是懒汉，手是好汉不怕，一点也不可怕，不难，一点也不难。 在这天，我清楚地感受到今天不想做作业地心情，抵触、逃避、恐慌、焦虑。。。。。。因为预知了困难，提前看GitHub 上的issues里都是关于day11作业的困惑和疑问，心里多少有些抵触。但是我知道只有做了才能解决，而不是空想。逃避没有任何用，把任务分解，一句话一句话地去实施。 随着着手敲代码的开始，这一天没有想象中困难，最后完成了day11-12的任务。 收获总结： 深刻理解了，写代码如同搭积木，一个函数如同一块乐高积木，只要一块一块加上去，就具像化了自己的目标。 一直听说python爬虫技术，今天终于得以实施，抓去了张小龙的演讲稿并做了处理，返回了邮件。 一直听说微信机器人，今天又亲自实施，和微信好友互动有无，她给我文章，我给她文章的数据，是自动的哦。 这次我好像真的很可以确信，学python不会再半途而废了，也许日后如同excel一样，用的机会越来越多了。 敏而好学，不耻下问—-训练营第六天最终的一天来到了，全部学完了训练营的任务，中间有困惑，有惊喜，最终收获的是满满的知识和弥足珍贵的自学体验，升级了自学的操作系统，对未来编程技能的使用充满了信心。 关于编程的思考 1真正理解了编程就是搭积木的过程。尤其是在day11作业开始，把各种函数放到一起，去完成自己的目标。函数就是手里的工具，建筑工人的砖头和水泥，人们的交通工具，摄影师的单反，学生的铅笔和橡皮，化妆师的化妆品和化妆工具，它只是让我们轻松完成目标的手段。最主要就是得先‘用’起来，只有用起来，才能直到自己的需求，正如不需要会修车才能开车，也只有开了一段时间的车才能清楚地知道自己到底需要什么功能，不需要什么功能。有人说，不都得先了解清楚了才能用吗？这种想法我认为挺害人的，大多数人的坏习惯，是从来不需要了解清楚危害就已经开始做了，比如填鸭式学习，比如抱怨，比如不健康的饮食习惯，但是要是想开始学习某项技能了，却谨慎了起来，给自己找一堆理由进而可以拒绝进化。需要大概了解一下原理？需要。需要着重看一下说明书吗？非常需要。 李笑来老师说过： 你不用去坚持，不用去挣扎，这时候是自己在“用”，而不是在“学”。我们关注的不是英语字句本身，而是文字承载的内容，英语只是挡在我们和内容之间的毛玻璃，时间久了，就会越磨越薄。 这句话对自学编程也是一样的好用。我们关注的不是编写代码本身，而是背后的思维方式。 学会顶级聪明人的思维方式，才是自学编程最大的收获。]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-曾对电脑不熟悉，用20年前的4级英语水平，我却坚持写出了通往未来的代码]]></title>
    <url>%2F%E5%AD%A6%E5%91%98%E6%95%85%E4%BA%8B%2F1901060005-%E6%9B%BE%E5%AF%B9%E7%94%B5%E8%84%91%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%8C%E7%94%A820%E5%B9%B4%E5%89%8D%E7%9A%844%E7%BA%A7%E8%8B%B1%E8%AF%AD%E6%B0%B4%E5%B9%B3%EF%BC%8C%E6%88%91%E5%8D%B4%E5%9D%9A%E6%8C%81%E5%86%99%E5%87%BA%E4%BA%86%E9%80%9A%E5%BE%80%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[曾经的迷失我叫代智国，来自深圳，2002年大学毕业，2004来到深圳，恍恍惚惚，蓦然回首已经在深圳生活了15年。10年前开始创业，现在是一名中小企业老板，从事餐饮食材贸易，开设连锁餐厅。团队的慢慢成熟，自己的自由时间相对宽裕一点，有时会迷茫、焦虑甚至迷失。未来是什么样子？现在的自己能够适应未来吗？怎样才能更好的读懂未来、适应未来？。。。。。。 在无数的疑问中，疯狂的参加线上和线下的学习，开启了学习和自我成长之旅。过多的线下的学习，使自己疲惫于到处奔波，反过来思考和复盘的时候又感觉收获不大，有些痛惜过去徒劳的学习时间和经历。痛定思痛，决定慎重的选择学习课程，不再盲目、飘荡奔逸的随从。这时目光转向了线上学习平台，出于对知识的贪婪，又同时参加了5个左右的线上平台，在信息的过滤中慢慢的做着自己的选择和判断，信息质量不高的平台自己很少光顾了，有的直接卸载。 为了保存精力，为了不再浪费宝贵、公平、一去不复的时间资源，目前跟随为数不多的课程，笑来老师的课程是其中之一。当然，对于笑来老师的课程自己也是经历了怀疑、迟疑到相信的过程，虽然笑来老师自称“硬核鸡汤”传作者，不过能够感受着笑来老师的价值观引导是可敬的，他所说和所行都是一致。是真正的“知行合一”的践行者。笑来老师如此的笃定前行可能基于他对”成功“概念的定义： 所谓的成功，无非是“用正确的方式去做正确的事情”。 价值观是对的，做的事是对的，所需要的做的也只有用正确的方法坚持，而笑来老师就是如此的走过来，他就是自己前行的导师，是前进路上”填坑“的向导，有如此通过践行获有真知的老师值得跟随。 为什么学习Python通过一个线上学习APP订阅了笑来老师的《通往财富自由之路》，对自己的很多认知有了很大的触动和颠覆。追随笑来老师来到了Python自学营。当时决定学习Python下了很大的决心，在自己原来的认知世界中从来就没有编程的概念，因为自己平时电脑用的都少，编程更是想都没有想过，因为编程是什么都没有概念。电脑的不熟练、20年前的4级英语水平毕业后就没有使用过，任何一个方面对自己自学Python都是一份大的挑战。 既然决定学习就有必要了解什么是Python，于是通过网络搜索查阅的大量资料，终于了解了一点点概念。虽然还是不懂，虽然有害怕过露怯，想学又害怕压力而退缩，在无数次的纠结后，下定决心挑战自己。想到笑来老师说过： 你原本有机会，却因为害怕羞耻而放弃…… 最终，你一无所成，当然应该羞耻. 既然要做时间的朋友就要做对得起自己和时间的事情，未来社会变化程度之大是自己难以想象的，不想在人工智能和物物相连的世界中茫然无措，不想做未来的 “文盲”，自己感觉学习程序语言势在必行。于是在自学营报名、缴费，开始了开智学习。 坚持开始的学习的确是如自己所料，困难比较多，基本上是用了一天的时间才算搭建好了开始学习的电脑里的环境。过程中有过烦躁，有过想放弃，如黑夜中摸索前行，克服心理障碍、语言障碍、知识障碍的过程中缓步前行。印象特别深的是在“对象”这个概念了纠缠了4天左右时间，能够感受到理解和应用“对象”对于能否学好Python特别重要，虽然不能准确理解“对象”到底重要在哪里。 当时的感觉：自己如一只口渴的乌鸦，眼前明明摆着一只装着水的瓶子，可悲的是瓶身高、瓶口小，任你再怎样着急，水依然在瓶子里，看得见但是喝不到。 自己在脑海里搜寻着解决当下问题的方法，期待能够找到解决问题的答案。最终还是用笨拙的、缓慢的、折磨身心的方法，一点点、一字不漏的阅读、阅读、阅读。。。。。。一点点的敲出代码、调试代码、修改甚至删除代码，如此的重复、重复。。。。。。第四天当看到书中概念的时候，瞬间感觉是如此的亲切，每个字仿佛都能够读懂了，它们所构建的图案都在脑海中浮现，是如此的清晰，是如此的让人愉悦，是如此的让人热血沸腾。 已经记不清楚什么时候有过这样的感觉了，能够确定是那是很久以前的事了。时间和坚持可以解决任何你想解决的问题，只要自己不放弃就没有任何外在的因素能够阻止你的前进，即使是在人生的谷底也会奋力前行。因为坚持让自己走出了想放弃学习的念头，因为坚持找到了自己继续前进的勇气和力量，因为坚持仿佛能够感受到时间的友好，因为坚持自己的内心仿佛光亮了许多。 学习中点滴收获自学营14天的学习，从开始的更多是想挑战自己的出发点到对Python有了一些兴趣，看到一次次敲出的代码能够运行出来，这种即时反馈的喜悦和成就感是其他学习中没有体会过的。 14天的坚持，编程零基础的自己有了继续学习Python的勇气和动力。 14天的坚持，渐渐的发现解决同样的问题可以有不同的结构、不同的算法，在学习和借鉴的过程中，当发现一种实用、简洁而优美的程序时，那种心情特别开心，赞叹的同时更多是感受事物和心情的美好。 14天的坚持，使自己不再抵触、抗拒阅读英文教程。 14天的坚持，在应用中学习Python，虽然学习中的应用还很简答，看着原本陌生的语言在解决着现实中的问题，原来的陌生和距离感消失了，它与我每天的生活是如此的贴近。 14天的坚持，让自己坚信没有什么是不可战胜的，问题的根本是你想不想、肯不肯去做，道理就是这么简单。。。。。。 14天的坚持，自己收获的太多太多，也许这就是用笑来老师的话说“入门”了，只要坚持学习并勤加练习可以更熟练的使用它。 曾经不识字是文盲，后来不懂英语是文盲，再到不懂基本计算机操作技能是文盲，到现在和不远的未来，不懂数据分析基本与文盲无异。。。。。。 自己能够清晰的感受到，学习Python的过程中，因为其知识浓度、知识难度对于自己都是很大的挑战。为了完成学习要不断的克服学习过程中出现的各种性格弱点，比如惰性、烦躁等等不好的情绪。克服这些人性弱点不仅仅是学习的需要，更是工作、生活甚至人生的需要。可以说学习Python不仅让自己懂得了一门语言，学会了一项技能或手艺，更加重要的是同时也在净化自己的”情绪底板“，可谓一举多得，事上磨练从来都不是虚言。 “潺潺溪水，肆意汪洋。” Python就是那个解未来之渴的“水之源”，未来就是无数个今天的延续。为了自己不成为未来的文盲，为了子女能够更好的生活在未来的时代，学习Python是自己的需要，自己也会在学习中不断地完善学习方法，持续的学习，为在未来遇见更好的自己而不是日趋堕落的自己而努力、为了成为孩子的榜样而努力。 天行健，君子以自强不息！ 14天的坚持，学习历程的记录：day1 收获总结： 1.刚接到任务就小紧张，在安装Anaconda的时候，就浪费了不少时间。更换版本重新下载安装后问题解决。还有就是运营Github最好是在googlo浏览器中运营，不然会很多问题。 2.第一次提交作业，教练回复没有READ.md，helloworld.txt多了一个txt，文件变成了helloworld.txt.txt。重新在本地仓库调整文件，才清楚作业要求的txt后缀系统自动添加，不需要文件命名时添加后缀。通过issue的问答中学习到README.md是文本文件。自己原来只是在建了一个文件夹。 3.在Github destop的commit耽搁了不少时间，原来commit要一个一个勾选。 备注：1.本地仓库变更之后要在github destop界面左下角完成commit，并且修改的内容要一个一个勾选，逐个commit。 2.commit之后github destop界面的push按键会变绿，点击之后就会同步远程仓库github中。通过pull request与master合并。 day2 学习总结： 1.主要的问题还是英文阅读上的困难，本来就不懂机器语言，再加上不熟悉的英语，难上加难。下载VS Code后设置Python环境和参数耽搁了很多时间，在摸索陌生的知识感觉就是在黑夜里前行，每走一步都很小心。体会到真正的自学是能够改变一个人的思维模式，改变人的认知。 2.在fork老师的新书，clon到本地文件夹时也因为掌握的不好耽搁了一点时间。首先路径都不完全确定，经过思考系统间的关系，几次试错，搞定。完成一项任务还是很开心。 day3 学习总结：1.拿到作业，感觉内容不多，看到编写计算器程序就懵了。一点头绪都没有，平时用excel都少，对于函数没有概念，感觉大脑抛锚了。那就先了解学习python的函数，即使了解一点函数，编程的逻辑都没有，两难相加是1+1＞2！运算程序只好上网借鉴别人的，感谢他们。2在程序的运行上面也纠结了很久，在教练和同学的帮助下，跌跌撞撞搞定。感谢大家。 day4 学习总结： 1、经过多次运行程序，终于发现一个小细节：函数结束都需要有冒号（：）才能被识别正确格式。 2、学习理论的同时要同步在VS Code python 环境中码程序、运行反复操作，才能慢慢有一点感觉。 3、刚刚接触python 语言，感觉 for…in 和while 都是很好用，一定要明白他们的使用规范，才能用起来比较舒服。 4、不断地学习，不断地试错，就一定会有收获。 5、暂时的学习都是站在前人的肩膀上，感谢他们。 day5 学习总结： 1、这两天被作业折磨的受了内伤，真心感觉这次作业的难度大，太多不知道、不熟悉、不理解的概念、函数、逻辑…… 2、感谢在卡壳的时候教练和老师提供的帮助，很多时候就在一个坑里出不来了，原因还是概念不清晰。开始都搞不清楚还有列表、字符串、数组等等概念和差异，概念不清楚函数的使用就不可能对。在复盘学习的时候要加强概念的理解，多用、多试错才能更好的学习。 3、深刻体会到人生就是活在大脑的算法里，同样的问题解决可能有很多途径，同时也一定有一条最优、最简洁的路径就看你的知识储备和思维开阔的程度。 day6学习总结： 1.今天作业相对顺利，能够大概知道程序调整的方向。 2.还是要加强对于函数和概念的理解。 day7 学习心得： 1.今天作业在DAY6基础上进一步深化学习，没想到day6程序的坑在day7作业就是井，为了出井需要先出坑。自己原来的程序不能区分中英文，对于中英混合的列表就无法完成词频统计。在这个问题上纠结了一个上午，在教练的指导下，借鉴同学的程序才完善了自己程序的窟窿。。 2.在模块调用上开始也停住了，文件夹、文件、程序、函数的空间关系有些不清楚，停下来看了下书梳理出关系，问题迎刃而解。 day8 学习总结： 1.虽然作业都是在前一天的基础上逐步推进，但是感觉学起来还是有些吃力，对于函数的概念理解和使用方法不能够透彻理解，很难单独完成程序。每天拿到作业都是先学习知识点，再尝试完成作业，同时也发现如果按照这个路径作业完成就需要很长时间，甚至会拖延。看到其他同学能够短时间完成作业，很佩服他们同时也在思考自己的学习方法是不是有问题。希望同学们交流、指导。 day9 学习总结： 1.现在的情况是能够看懂简单的程序，在借鉴同学或者网络资料勉强完成作业。对于函数的使用规则和参数设置都不熟悉，要在作业中慢慢学习。这次主要是调用统计函数，怎样融合到自己的程序中花费了比较长的时间。 2.对于python的语言规则还要多看书多练习。 day10 学习总结： 1.今天作业在昨天的基础上学习了增加了第三方库的安装和使用，jieba.cut在默认状态下就是精准分词，只要在上次作业的基础上做简单微调，添加jieba函数就可以了。 2.在利用函数的同时，要注意参数的转换，列表转换字符串，字符串转换列表是时常都有也经常容易忽略。 day11 学习收获： 1.这次学习有两个比较耗时的问题出现，一个是VS Code在运行过程中自动退出，再登录时无法终端运营，并且程序中的问题也不能提示。试了很多办法，最后是重新下载安装Anaconda并且删除旧文件夹，才恢复了正常使用。第二个问题：发送邮件总是提醒下图中的问题，两天时间经过教练们的细致、耐心的指导下终于解决问题，感谢他们。 2.任何刻意练习都是要在练习中学会解决问题的能力。 day12 学习收获：参照学习资料，照猫画虎竟然成功登陆微信小号的网页版，还是有点小意外、小激动，没想到几行代码就能够实现这么多的功能，小惊喜。经过十几天的学习逐步对python有了一点点认识，还是很感叹计算机语言的魅力，就像人的思想一样虽在灯火阑珊处，它的作用做事随时可见的。计算机语言有内置参数，高手还可以自定义很多函数既能高效解决问题，又能时时看到自己的劳动成果输出，很美好，自己学习的路还有很长，希望自己能继续深入的学习下去。 day13 学习收获： 1.怀着激动、忐忑的心情迎接第13天的作业，在上次作业的基础上调用新的函数，输出柱形图。实际在完成程序的过程中还是不能够准确的使用函数。经过学习同学们的作业，才勉强看懂程序中的逻辑结构和函数使用方法。 2.感觉自己是在对照程序理解逻辑，还不能够梳理出自己的逻辑，用机器语言表达出来，即使是简单的功能，这种思维的转换还是不顺畅。 day14 学习感悟：1.走完Python的入口之旅，收获很多，最大的感悟就是自学是活在未来的必要路径，在学习的过程中有太多自己的障碍需要克服，在克服障碍的过程中不断的学习、成长。2.感谢在学习过程中给予帮助的辅导员、助教、教练，感谢给予帮助的同学们，感恩同行！]]></content>
      <categories>
        <category>学员故事</category>
      </categories>
      <tags>
        <tag>自学营</tag>
        <tag>Python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010014-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010014-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：白头翁学号：1901010014 工作背景销售类 自我介绍大家可以叫我白头翁，从事销售类工作。 参见Python 训练营进阶课程，是因为想换个行业工作，因为的的确确这是个变化频率与幅度都在不断加大的时代，10年前我还不知道二维码是什么，但今天二维码已经成为了移动互联网的入口，现在出门带个手机就可以搞定许多生活事项，且2009到2019这10年技术发展非常快，移动互联网、云计算、大数据、人工智能、区块链…… 都在一步步影响着各行各业，与其将来被技术革命，不如现在趁年轻，相对有充裕时间和充足精力，去拥抱变化。 目前我在反复看《自学是门手艺》这本书，能看懂一些 Python 程序，但自己实际动手写个小程序还是很困难。 愿我们自学 Python 进阶训练营的同学们一起讨论问题，共同进步，用三个月时间让自己学有所获，用一年时间把自学这门手艺和数据分析能力磨练的很好，足够应对日常工作生活所需。一起加油！]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>销售</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070038-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901070038-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名:张书忠 工作背景私募股权投资，主要从事股权投资工作 自我介绍金融行业从业者、Python初学者 为什么想学习数据分析我想学习数据分析有以下几点：1.我之前看了很多做IDC的公司，他们普遍说目前国内对于数据的分析和应用处于非常初级的阶段。我之前也没有研究过这个东西，所以就着这次机会去学习一下。2.目前自己时间相对比较多，也想找一件事情让自己不闲下来。而编程我感觉比较适合自学，自己学习的知识可以马上用电脑去实践，可以获得很好的反馈。3.我认为在编程的过程中可以很好的锻炼自己的思维方式，比如严谨的思维。 希望学完之后的应用场景学完之后的应用场景我还真的没有深入想过。目前能想到的就是，可以自己去编写一些程序，从而减少自己的一些重复性工作。 目前自己的学习阶段和疑惑我目前还处于学习了一些基本概念的阶段，并且这些概念也都是基本了解，还不能熟练的去运用。应该算一个初学者。目前最大的困惑就是如何很好的表达出自己所遇到的困难。比如如何比较好的搜索出自己所需要的函数。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>股权投资</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020015-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020015-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：李浩天，只接受三个正确的打开方式 —— 浩天、奇点、战友学号：1901020015 工作背景目前在 互联网+物流 领域深耕，说的高大上一点就是建设中国运输网络主干线。岗位性质更多的集中在经营分析、项目管理、战略研究三个方面 自我介绍一个类数据分析从业者、一个非资深物流人、一个追求成长速率的学生 学习目的最开始的原因其实很简单，想要拾起大学时学习的编程知识。这来源于两个基本诉求： 由于工作的性质，存在外部数据的采集需求，而IT资源又很稀缺，特别是在自己想要研究一些东西的时候。所以想要自己具备一些外部数据的获取能力，可以独立完成 数据爬取 另一个需求是来自于多方面的，想要自己的效率做进一步的提升，并且解锁更多的可能性。比如，工作中可以通过编程替代一部分Excel的工作，更快速的实现一些想法或者编写一个程序完成重复性的内容，脱离 “大表哥” 的困扰 那天我们沟通完之后，关于数据分析的发展方向，我在网上检索了一下，有一篇文章说的最讲究，文章说有四个方向： 业务数据分析(原文就直接叫数据分析，方便理解换了一个名字)：这类基本有两个主要任务：一个是业务数据体系化大白话来说就是业务指标体系的建立，一个是业务问题的解决比如为什么活跃用户数下滑增量放缓等。并且对于传统行业也会存在线下业务的规划包括选址等，会涉及到宏观数据，需要搜索及调研能力。这个岗位貌似说是最适合走向管理岗位的一个职位 数据挖掘： 看下来没有特别明确数据挖掘和数据分析的差别，给我的感觉是数据挖掘貌似更加理论化一些，涉及到模型的建立算法的应用。比如机器学习、协同过滤、关联规则、PageRank 等。在最优化问题的应用上，看到的例子是：外卖行业，如何寻找骑手效率最大化的最优路径 从问题解决的角度基本可以分为几个步骤：问题抽象-&gt;模型建立-&gt;线上部署。在岗位分工上面，问题抽象基本由数据分析完成，模型建立可以是数据分析也可以是数据挖掘，线上部署可以是数据挖掘也可以是数据工程。所以我大致的理解是数据挖掘和数据分析是一脉相承的关系而已，解决的问题难度不同 数据产品：这个现在有两种理解，一种是具备强数据分析能力的PM，一种是公司数据产品的规划者。前者以数据导向优化和改进产品，后者类似于产品经理，主要参与数据相关的产品项目：包括大数据平台、埋点采集系统、BI、推荐系统、广告平台等 数据工程：相对数据挖掘来说更倾向于更底层的工程实现和架构，很多工作是围绕 ETL / DW / BI 进行展开 综合看下来，评估了一下，自己现在应该只涉及到业务数据分析的工作，最开始的诉求也是希望在业务数据分析的路上走的更远一些。可这个并不妨碍那颗数据挖掘的心，关于数据挖掘这里当下有一个比较大的疑问，也希望后续可以得到解答，就是数据挖掘究竟可以解决那些类型的问题，它的边界又在哪里？ 最后特别想说一句感谢。因为最近的自己像是打开了一扇门，当编程、英语以及区块链一个一个迈入自己的视野，感觉自己的眼前像变了一个世界，特别深刻的感受到 “井底之蛙” 的感觉。也因此改变了很多自己的行为，曾经可以忍受的突然就忍受不了了，比如上不了外网 [捂脸笑] 追加一下： 这两天我看完了《自学是一门手艺》的一个链接文章 What exactly can you do with Python? ，就特别想提一个需求：在学习的过程中能不能更多的介绍一下Python在数据分析或者数据挖掘领域有哪些实际的应用场景]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>互联网+物流</tag>
        <tag>追求成长速率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100001-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100001-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王学闻 , 大家可以叫我学闻学号：1902100001 工作背景目前从事Java程序员工作(三年工作经验) 自我介绍我是一名在职的Java程序员 , 在这几年的工作中除了敲代码 , 看的最多的就应该是很多所谓的产品经理根据自己的并不实际的调查确定用户的需求 , 然后进行项目开发 , 结果开发的产品犹如石沉大海 , 然后……就没有然后了 . 作为一个底层业务的实现者 , 我深知这种现象在软件开发的普遍性 , 也知道在那些所谓的产品经理眼中用户 “应该” 有的需求是不对的 , 明白这些又怎样 ? 如果换我去做同样的工作 , 或许也会犯一样的难 . 也会一样淹没在无边无际的不确定性之中 . 我想这样的焦虑并不只有我一个人感受得到 . 然而大数据却能解决这样的问题 . 我们可以运用大数据思维去消除不确定性 , 利用它实现精准服务 , 它还能帮我们动态的调整做事策略 , 还能用它去发现未知规律 , 等等等等 . 能够做到让我们的分析更加贴近现实 , 我想大数据思维应该成为每一个有志于在未来数据大潮中过好日子的人的必修课 . 目前的学习阶段 , 初级]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>Java程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100002-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100002-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息 姓名: 苟利桥，当然也有叫大桥的，叫小桥的，等等。 工作背景 目前从事IT工程与运维项目的实施工作，主要是服务器存储以及华为云计算的实施交付于维护相关工作。 自我介绍 虽然岁数不大，30都还差点，但是一路走来一直在学习，从中受益匪浅，我以前大学毕业后是搞基础网络维护与个人pc电脑维保工作的，到后来的企业网维护，企业网IT维护，再到现在的企业网、运营商IT云计算维护。由于我本人背景并不好，所以从技术中获益的幅度更是十分的可观，总是有几句话一直觉得特别受用: 凡事有失有得有得有失，有些事情别人不愿意做的、累的、看不起的可能里面会有机会。 君子性非异也，善假于物也。下面再详述。 为什么想学习数据分析，希望学完之后应⽤在什么场景 这里接着说刚才那句话，像我们很多一线的工程师是骨子里是不乐意搞技术这个东西的，理由很简单就是不受用，性价比很低，毕竟学习技术研究技术非常的花精力，而实际的效益确并不好，这点我自己是深有体会，所以好多一线工程师实际上干的是业务的活，就是变相的搞销售拿提成，真有解决不了的问题，有二线，有研发支持，压根不需要自己花精力去研究。 交代一下背景，更加方便于自己阐述学习的动力和心态。本人一直在工程师岗位那么多年，深刻的认识到技术的重要性，概况起来就两个字效率。同样是做一个事情，我懂技术，我多会那么一些工具，在故障诊断上，工程交付上，思维逻辑上，完全能成指数级的方式改善自己的工作方式，大大提升效率，节约出更多时间来进一步加深扩充技术，从而实现良性循环，量变到达质变，接着而来的就是生活的改变。 话又说回来了，为什么要学习数据分析，是完全因为工作么？显然不是，显然我们工作对数据分析的依赖并不大。如上文讲到，技术改变了我分析问题，看待问题事务的逻辑，提供了我终身学习进步的可能，进而深刻的认识到当下时代从数据中获利的趋势必然会大于我通过工作时间来获利的可能。 好了，上文讲到我们想通过数据来获利，诶就是挣钱，不以挣钱为目的的学习技术那都是耍流氓。 那么我们学完后要干点什么呢： 当然学习数据分析只是我要干的事情中的一部分，就目前我最终想干的事情是通过爬虫、数据分析、信息论、离散数学等，建立一个股票等二级市场涨跌的交易模型，极大概率从中实现获利。 同时，还想通过数据分析，爬取与分析当下的电商平台，比如美团，淘宝，大众点评，链家等等平台的优惠信息以及其他商业价值信息，帮助实现获利决策模型。 最终目的就是从当前的通过完完全全的工作时间获利的模型中解脱出来，创造更多的可能，实现财务自由。 目前自己的学习阶段和疑惑 当然想干那么多事情，单纯只靠数据分析是远远不够的。所以还是要关注当下，沉下心来，一步一个脚印的前进，虽然看过很多书，懂得很多道理，但是我每天依然还是在做调系统、写代码。 因此当下依然还是处在通过代码来调优工作效率的阶段。不过已经能通过爬虫获取到海量数据，存储数据了，所以完全可以进一步进阶来分析这些数据，展现这些价值数据的时候了。 既然如此，那大家就一起共同加油，共渡剩下的阶段吧。 Fighting]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>IT工程运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE2]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 2 +Python 编程导论（第2版）（第2章的2.2-2.4） 学习用时：3.5小时 学习笔记收获总结： Spyder 快捷键 多行注释 Ctrl + 1 取消Ctrl+1 ；或者Ctrl+4块注释，Ctrl+5取消。 最简单的分支型程序是条件语句，if Boolean expression: ​ block of code ​ elif Boolean expression: ​ block of code ​ else: ​ block of code 缩进在Python中是具有语义意义的。Tab或四个空格不要混合使用。 条件语句可以嵌套；在检验条件中使用复合布尔表达式是非常方便的。 print()函数每个参数之间自动加空格。 +两侧都是数值对象时就是plus，两侧为字符串时，表示连接，没有空格。 +不能操作str和int；*可以操作str和int，变成重复操作符。 每行代码都要手动输入一遍，照着打都经常容易错。 需要程序多次做同一件事情的时候，可以使用迭代语句：while loops: while : ​ ​ ​ … for loops: for in range(): ​ ​ ​ … 遇到的难点与问题（是否解决）：对迭代语句的理解还很模糊，明天继续学习迭代语句。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet3(P1)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet3(P1)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 3 (ZIP) 打卡天数：D08 作业(Problem 1: Word scores):The first step is to implement a function that calculates the score for a single word. Fill in the code for get_word_score in ps3.py according to the function specifications. As a reminder, here are the rules for scoring a word: The score for a word is the product of two components: First component: the sum of the points for letters in the word. Second component: either [7 * word_length - 3 * (n-word_length)] or 1, whichever value is greater, where: word_length is the number of letters used in the word n is the number of letters available in the current hand You should use the SCRABBLE_LETTER_VALUES dictionary defined at the top of ps3.py. Do not assume that there are always 7 letters in a hand! The parameter n is the total number of letters in the hand when the word was entered. Finally, you may find the str.lower function helpful: 123s = “My string”print(s.lower())&gt;&gt;&gt;&gt; “my string” If you don’t know what this does you could try typing help(str.lower) in your Spyder shell to see the documentation for the functions. 作业心得这里有个2关键点： [7 * word_length - 3 * (n-word_length)]，如果计算值小于0，则 Second component 为1 一定要认真看 Introduction章节的Scoring部分，从中得知这道题是要计算 First component 和 Second componen 相乘的结果 要认真看 test_ps3.py 的 test_get_word_score 函数，参考这个函数可以知道如何测试 关键函数的理解deal_hand(n):该函数返回一个字典类型数据，包括 ceil(n/3) 个元音和若干个辅音与对应的次数，元音与辅音可重复 update_hand(hand, word):将存在 hand字典中 key 为 word 的元素删除并返回，但不修改原 hand 变量 学习的新函数： Python ceil 函数:向上取整; ceil() Python choice 函数: 从列表、元组、字符串中随机选择一个元素;choice 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361# 6.0001 Problem Set 3## The 6.0001 Word Game# Created by: Kevin Luu &lt;luuk&gt; and Jenna Wiens &lt;jwiens&gt;## Name : &lt;your name&gt;# Collaborators : &lt;your collaborators&gt;# Time spent : &lt;total time&gt;import mathimport randomimport stringVOWELS = 'aeiou'CONSONANTS = 'bcdfghjklmnpqrstvwxyz'HAND_SIZE = 7SCRABBLE_LETTER_VALUES = &#123; 'a': 1, 'b': 3, 'c': 3, 'd': 2, 'e': 1, 'f': 4, 'g': 2, 'h': 4, 'i': 1, 'j': 8, 'k': 5, 'l': 1, 'm': 3, 'n': 1, 'o': 1, 'p': 3, 'q': 10, 'r': 1, 's': 1, 't': 1, 'u': 1, 'v': 4, 'w': 4, 'x': 8, 'y': 4, 'z': 10&#125;# -----------------------------------# Helper code# (you don't need to understand this helper code)WORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # wordlist: list of strings wordlist = [] for line in inFile: wordlist.append(line.strip().lower()) print(" ", len(wordlist), "words loaded.") return wordlistdef get_frequency_dict(sequence): """ Returns a dictionary where the keys are elements of the sequence and the values are integer counts, for the number of times that an element is repeated in the sequence. sequence: string or list return: dictionary """ # freqs: dictionary (element_type -&gt; int) freq = &#123;&#125; for x in sequence: freq[x] = freq.get(x,0) + 1 return freq# (end of helper code)# -----------------------------------## Problem #1: Scoring a word#def get_word_score(word, n): """ Returns the score for a word. Assumes the word is a valid word. You may assume that the input word is always either a string of letters, or the empty string "". You may not assume that the string will only contain lowercase letters, so you will have to handle uppercase and mixed case strings appropriately. The score for a word is the product of two components: The first component is the sum of the points for letters in the word. The second component is the larger of: 1, or 7*wordlen - 3*(n-wordlen), where wordlen is the length of the word and n is the hand length when the word was played Letters are scored as in Scrabble; A is worth 1, B is worth 3, C is worth 3, D is worth 2, E is worth 1, and so on. word: string n: int &gt;= 0 returns: int &gt;= 0 """ word = word.lower() first_component = 0 for letter in word: first_component += SCRABBLE_LETTER_VALUES[letter] second_component = 7 * len(word) - 3 * (n - len(word)) if (second_component &lt; 1): second_component = 1 return first_component * second_component # "it" 7*2-3*(7-2) = 14-15 = -1 # "was" 7*3-3*(7-3) = 21-12=9+6 # [7 * word_length - 3 * (n-word_length)] # pass # TO DO... Remove this line when you implement this function## Make sure you understand how this function works and what it does!#def display_hand(hand): """ Displays the letters currently in the hand. 显示当前手里的字母 For example: display_hand(&#123;'a':1, 'x':2, 'l':3, 'e':1&#125;) Should print out something like: a x x l l l e The order of the letters is unimportant. hand: dictionary (string -&gt; int) """ for letter in hand.keys(): for j in range(hand[letter]): print(letter, end=' ') # print all on the same line print() # print an empty linedisplay_hand(&#123;'a':1, 'x':2, 'l':3, 'e':1&#125;)## Make sure you understand how this function works and what it does!# You will need to modify this for Problem #4.#def deal_hand(n): """ Returns a random hand containing n lowercase letters. ceil(n/3) letters in the hand should be VOWELS (note, ceil(n/3) means the smallest integer not less than n/3). Hands are represented as dictionaries. The keys are letters and the values are the number of times the particular letter is repeated in that hand. n: int &gt;= 0 returns: dictionary (string -&gt; int) """ hand=&#123;&#125; num_vowels = int(math.ceil(n / 3)) for i in range(num_vowels): x = random.choice(VOWELS) hand[x] = hand.get(x, 0) + 1 for i in range(num_vowels, n): x = random.choice(CONSONANTS) hand[x] = hand.get(x, 0) + 1 return hand## Problem #2: Update a hand by removing letters#def update_hand(hand, word): """ Does NOT assume that hand contains every letter in word at least as many times as the letter appears in word. Letters in word that don't appear in hand should be ignored. Letters that appear in word more times than in hand should never result in a negative count; instead, set the count in the returned hand to 0 (or remove the letter from the dictionary, depending on how your code is structured). Updates the hand: uses up the letters in the given word and returns the new hand, without those letters in it. Has no side effects: does not modify hand. word: string hand: dictionary (string -&gt; int) returns: dictionary (string -&gt; int) """ pass # TO DO... Remove this line when you implement this function## Problem #3: Test word validity#def is_valid_word(word, hand, word_list): """ Returns True if word is in the word_list and is entirely composed of letters in the hand. Otherwise, returns False. Does not mutate hand or word_list. word: string hand: dictionary (string -&gt; int) word_list: list of lowercase strings returns: boolean """ pass # TO DO... Remove this line when you implement this function## Problem #5: Playing a hand#def calculate_handlen(hand): """ Returns the length (number of letters) in the current hand. hand: dictionary (string-&gt; int) returns: integer """ pass # TO DO... Remove this line when you implement this functiondef play_hand(hand, word_list): """ Allows the user to play the given hand, as follows: * The hand is displayed. * The user may input a word. * When any word is entered (valid or invalid), it uses up letters from the hand. * An invalid word is rejected, and a message is displayed asking the user to choose another word. * After every valid word: the score for that word is displayed, the remaining letters in the hand are displayed, and the user is asked to input another word. * The sum of the word scores is displayed when the hand finishes. * The hand finishes when there are no more unused letters. The user can also finish playing the hand by inputing two exclamation points (the string '!!') instead of a word. hand: dictionary (string -&gt; int) word_list: list of lowercase strings returns: the total score for the hand """ # BEGIN PSEUDOCODE &lt;-- Remove this comment when you implement this function # Keep track of the total score # As long as there are still letters left in the hand: # Display the hand # Ask user for input # If the input is two exclamation points: # End the game (break out of the loop) # Otherwise (the input is not two exclamation points): # If the word is valid: # Tell the user how many points the word earned, # and the updated total score # Otherwise (the word is not valid): # Reject invalid word (print a message) # update the user's hand by removing the letters of their inputted word # Game is over (user entered '!!' or ran out of letters), # so tell user the total score # Return the total score as result of function## Problem #6: Playing a game### procedure you will use to substitute a letter in a hand#def substitute_hand(hand, letter): """ Allow the user to replace all copies of one letter in the hand (chosen by user) with a new letter chosen from the VOWELS and CONSONANTS at random. The new letter should be different from user's choice, and should not be any of the letters already in the hand. If user provide a letter not in the hand, the hand should be the same. Has no side effects: does not mutate hand. For example: substitute_hand(&#123;'h':1, 'e':1, 'l':2, 'o':1&#125;, 'l') might return: &#123;'h':1, 'e':1, 'o':1, 'x':2&#125; -&gt; if the new letter is 'x' The new letter should not be 'h', 'e', 'l', or 'o' since those letters were already in the hand. hand: dictionary (string -&gt; int) letter: string returns: dictionary (string -&gt; int) """ pass # TO DO... Remove this line when you implement this functiondef play_game(word_list): """ Allow the user to play a series of hands * Asks the user to input a total number of hands * Accumulates the score for each hand into a total score for the entire series * For each hand, before playing, ask the user if they want to substitute one letter for another. If the user inputs 'yes', prompt them for their desired letter. This can only be done once during the game. Once the substitue option is used, the user should not be asked if they want to substitute letters in the future. * For each hand, ask the user if they would like to replay the hand. If the user inputs 'yes', they will replay the hand and keep the better of the two scores for that hand. This can only be done once during the game. Once the replay option is used, the user should not be asked if they want to replay future hands. Replaying the hand does not count as one of the total number of hands the user initially wanted to play. * Note: if you replay a hand, you do not get the option to substitute a letter - you must play whatever hand you just had. * Returns the total score for the series of hands word_list: list of lowercase strings """ print("play_game not implemented.") # TO DO... Remove this line when you implement this function## Build data structures used for entire session and play game# Do not remove the "if __name__ == '__main__':" line - this code is executed# when the program is run directly, instead of through an import statement#if __name__ == '__main__': word_list = load_words() play_game(word_list)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901030012-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Cat学号：1901030012 工作背景地产、能源与自然资源领域涉外法律服务从业超过13年 自我介绍 自我介绍: 本人叫王露萩，朋友都叫我Cat。中国和美国加州执业律师。实际心理年龄只有4岁8个月左右，对世界开启了好奇心。我可以使用中文、英文。在学习使用Python和日文。 为什么想学习数据分析：不明白数据是什么，想知道现在所指的”数据“都是如何产生的、可以如何搜集、又是如何被分析的。数据分析本身是怎么被应用的。 希望学完之后应用在什么场景： 1 学完后搞明白自己的数据都可能有什么，是怎么被别人搜集、分析和使用的，然后自己好好学习一下怎么使用数据分析了解自己。 2 自己能编写脚本实现各国司法案例数据库内捕捉自己需要的关键词相关数据的功能。 目前自己的学习阶段和疑惑： 1 学习阶段：14天Python入门营毕业，MIT6.0001课程学习文稿到lecture8文稿的p12.（练习题做到 psets 1 part A） 2 疑惑： 4.2.1 语言概念定义的关联，范畴，暂时还没有梳理明白； 4.2.2 看见数字和图表内心深处阴影面积暂时还是会产生巨大压力影响自己的学习动作变形。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>里程</tag>
        <tag>起点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020008-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020008-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王娟芳 【同事叫我芳芳（年龄小的叫芳姐)，大家也可以这么称呼我(✿◡‿◡)】学号：1901020008 工作背景数智校园整体方案解决服务商 自我介绍大家好！作为新兴互联行业与传统教育业的结合体这样一个行业，关于大数据，关于AI，这些前端科技都在时时刻刻影响着我们。 作为商家，一定要成为两个行业的专家才能把路越走越宽。 作为企业主，势必要更快更好的学习，成长，才能不被淘汰。 作为个人，脑中没有对未来清晰的预见，只能让焦虑占据 而作为两个孩子的母亲，教给孩子什么，让孩子走什么样的路，脑子里没有清晰的概念也是不可行的。 关于为什么学习数据分析，我脑中没有一个清晰的定义。一开始进训练营的考虑是：这个世界有方法论，我想找到适合我的，切实可行的方法改变自己无一技之长的现实。后面觉得必须继续学习才能成为一技之长。 现阶段，我只坚定的相信一切都可以通过学习改变。随着学习的深入，也许可以帮我快速入门互联网行业应用于教育界。也许可以帮我理清脑中模糊的人生规划，也许能更清楚地看到未来，给孩子更好的教育。也许还会有更多意外的收获……]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>数智校园</tag>
        <tag>孩子母亲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050035-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050035-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：老罗学号：1901050035 工作背景网络维护和管理 自我介绍我是老罗，在广州工作，日常负责网络运行和维护管理工作。工作的老兵，编程的新手，很高兴有机会和大家一起参加数据营学习数据分析和处理，提高工作的效率和自我价值。 ####【为什么想学习数据分析，希望学完之后应⽤在什么场景】 工作20多年，大部分时间以通过系统出告警或用户投诉等传统的方式，来处理网络出现的故障或隐患，工作非常被动；而且随着网络的快速大规模的扩容，现有的人手和手段非常缺乏和落后，希望通过计算机自动收集日志和性能统计数据，分析和评估当前网络运行的状态，以实现对网络运行中的故障自动快速的定位和容量主动精准扩容。 ####【当前的学习阶段和疑惑】 前期参加了自学训练营，初步掌握了Python的程序的运行和基本函数规则等，后续希望通过本期数据营，学会和掌握一套数据分析和处理工具，支撑日常工作，实现对网络系统运行的自动采集、统计和分析，提高管理效率。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>网络维护和管理</tag>
        <tag>编程新手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070004-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901070004-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：小黎学号：1901070004 工作背景目前工作和普惠金融相关，涉及寻找客户，扶贫贷款发放回收，也涉及社区工作，培养客户良好的卫生健康习惯，普及理财知识等。 自我介绍为什么学习数据分析： 计划从事数据分析工作。 希望学完后应用到什么场景： 可以在新工作中灵活运用学习到的技能，而且可以很好的完成项目，成为一个优秀的数据分析师。 可以迁移分析问题解决问题的能力，让自己成为一个能独立思考的人。目前自己的学习阶段和困惑：完成了自学营初级阶段的学习，MIT的课程还在理解实践中。比较初级。困惑是遇到问题，不知道怎样高效的解决它，怎样使用编程语言去解决问题，不知道背后的思考方式，还有学习到的思考方式怎样落地。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>普惠金融</tag>
        <tag>社区工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010061-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010061-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Music学号：1901010061 工作背景会计 自我介绍我是一名90后南方人，从事玩具行业.为什么想学习数据分析：我对数据分析是没有接触过的，从自已的理解角度，数据分析的作用应该是收集数据信息，然后信息分析，帮助自已作出一些决策判断。我们是处在信息发达的环境，如何取得高质量的信息并学会分析学习。学习数据分析是利大于弊的。学后应用场景： 生活与工作中能使用数据分析来优化决策。学习阶段和疑惑：在几个月前参加了训练营，通过自学，初步认识了python。学完之后，感觉还是有些懵，感觉学完容易忘，不会灵活使用。之后进入到MIT的学习，重新思考了学习这件事情（为什么我学习后的知识容易忘，我应该怎么做，有什么学习方法是适合我的），通过看学习相关的书箱、网上找资料，找到了合适自已学习的方法，目前正在适应中。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>会计</tag>
        <tag>玩具行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自学训练营-MIT60001-DAY1]]></title>
    <url>%2FMIT60001%2F1901020043-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-DAY1%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 1 +Python 编程导论（第2版）（第1章+第2章的2.1） 学习用时：4小时 学习笔记收获总结： Computers only know what you tell them. Computers only do what you tell them to do. 计算机能且只能做两件事——执行计算与保存计算结果(perform calculations and remember results)，但它把这两件事做到极致。 计算机思维： 七种关系：1.大和小 2.快和慢 3.多维度和单一维度 4.网络和个体 5.自顶向下和自底向上 6.全局和局部 7.成本和表现 两个原则：1.等价性原则 2.模块化原则 ——（吴军的谷歌方法论） 算法：是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。（简单步骤，控制流，何时结束） 通用图灵机：可以接受任意一个图灵机 M 的编码 ，然后模拟 M 的运作。 邱奇-图灵论题：任何在算法上可计算的问题同样可由图灵机计算。（如果一个函数是可计算的，那么一定可以通过对图灵机进行编程实现这种计算。） 停机问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”,所有现代编程语言都是图灵完备的。 每种编程语言都有基本结构、语法、静态语义和语义。 Python的基本结构包括字面量和中缀操作符；语法定义了字符和符号组成句子的正确形式；静态语义定义了哪些语法有效的句子是有意义的；语义为每个语法正确又没有静态语义错误的句子关联一个含义。 程序如果没有正确运行，就应该表现出明显的错误。只要有可能，我们都应该以这种方式编写程序。 对象是Python程序处理的核心元素。Python有4类标量对象：int，float，bool，None 在Python中，变量仅是名称，没有其他意义（非常重要）。变量名可以包含大写字母、小写字母、数字（不能以数字开头）和特殊字符_，变量名称大小写敏感，保留字不能做变量名。 恰当的选择变量名和添加注释是提高程序可读性的好方法。 总结：看英文字幕虽然很难但是不会像中文字幕令人不舒服；明确计算机的边界，能做什么，不能做什么；学习计算机思维的相关知识很重要，得到有很多文章讲解，应该再看一些相关书籍；个人偏好一些概念的认真理解，会额外耗费很多时间，是否有用在以后的学习中会验证；养成好的编程习惯，先从变量名和注释开始；多输入代码，刻意练习的技巧可以考虑如何用在这里。遇到的难点与问题（是否解决）：对停机问题的理解还不够，先放放，过一周再看。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：金志坚学号：1901020043 工作背景医药行业，从事营销推广工作 自我介绍今年42岁，除了日常的管理工作所需，最想学好的就是英语和编程，一法通万法通，通过学习编程提高自己的自学能力，希望能保持终身学习的能力，也希望能给员工展示一切皆有可能，年龄不是问题。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>营销推广</tag>
        <tag>年龄不是问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901090043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：姜翔学号：1901090043 工作背景在上海从事过医药行业，金融期货行业，目前在家大部分时间学习，小部分时间在老家江西开发业务 自我介绍 我叫姜翔，之前从事过医药，金融行业，目前在老家有个办公室，生意一般，想寻求其他方面的突破。 之前有点编程基础，不想抛掉这门手艺，想重新拾取，加上Python的强大，高效，对数据分析，人工智能也有兴趣，而在这两个方面Python都有一定的优势。俗话说艺多不压身，也是想离校之后重新系统的学习一门课程，增强自学的信心，这很重要。 毕业到目前为止已有7年了，时间转瞬即逝，比起无聊的社交，真正用心的沉浸在一门手艺当中，这是让时间眷顾的最好方法了，每天坚持，沉浸其中，你会发现日子似乎过的没那么快了，心里获得的充实感和安慰是巨大的，我想每个成人都应该长期保持这种状态。而编程是比较容易获得所谓心流体验的，这是编程作为热门自学课程的原因之一。 我想了下，入门这么多年，应该是已经入门了，入门学习的最核心的字符串、整数类型、浮点类型、函数、类、模块、DIG、复杂度和数据结构都有一定的掌握，希望在之后进阶路上进一步加强理论和实践，做到不断挑战高要求，不断进步。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>自由职业者</tag>
        <tag>金融销售业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901060005-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：代智国学号：1901060005 工作背景企业经营者 自我介绍我叫代智国来自深圳，2002年大学毕业，2004来到深圳，恍恍惚惚，蓦然回首已经在深圳生活了15年。10年前开始创业，现在是一名中小企业老板，从事餐饮食材贸易，开设连锁餐厅。团队的慢慢成熟，自己的自由时间相对宽裕一点，有时会迷茫、焦虑甚至迷失。未来是什么样子？现在的自己能够适应未来吗？怎样才能更好的读懂未来、适应未来。。。。。。通过一个线上学习APP订阅了笑来老师的《通往财富自由之路》，对自己的很多认知有了很大的触动和颠覆。追随笑来老师来到了Python自学营，下定决心挑战自己。想到笑来老师说过： 你原本有机会，却因为害怕羞耻而放弃…… 最终，你一无所成，当然应该羞耻。 为了不让自己一无所成，要坚定也坚持的将Python学习进行到底。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中小企业老板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050081-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050081-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：QQ学号：1901050081 工作背景待业（无特定行业） 自我介绍作为一名 80 后待业大龄女青年，学习编程是为了使自己更快的适应巨变的社会，获得一个长期奋斗的方向。再选择数据分析作为进阶学习，以求先掌握一门技术作为谋生手段，并学会如何透过现象看清本质，在数据中获得最有价值的信息，不被表象迷惑，做出最有利于自我的长远决策。期望可以通过不断打磨自己的技艺，靠自己的双手过上自己喜欢的生活，由自己掌握的时间和节奏，不再活在别人设定的框架中。 目前学习阶段和学习困惑现阶段已经完成了入门训练营和 MIT 视频公开课的学习，还在继续了解 Python 的语言特性。不知道初高中数学都丢光了，数据分析能学得好吗？是不是先学会爬虫，再学习数据分析师会好一些？还是直接挑战数据分析师呢？要系统的学习，还需要学习哪些课程会更好呢？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>待业大龄女青年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学训练营学习7群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050119-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A07%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[姓名：王银/Galaxy 学号：1901050119 学习内容：Python 14 天入门 学习用时：46.5h 每一个概念都不简单，“自学”更是如此经验基础先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 查漏补缺那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。 早在3月份我就报了自学训练营，因为自己本来自由时间就不够充裕，担心无法在规定时间内配合作业学完书上的内容，而且对于搭建环境不太擅长，所以特意选了比较靠后的班次，给自己留足时间去攻关。可是，学而不用、学而不练，加上学习时间不紧凑，总是前学后忘，所以，直到开营一本书还是没有完整通读下来。 我用亲身经历证明，搭建环境真的非常摧残信心！我在开营前专门留出四五天时间通关，耗费很多精力，折磨死大批脑细胞……所幸最终基本上突围成功。正因为经历了这般艰辛的未雨绸缪，自学营前两天搭建环境和熟悉工具的作业才得以“轻松”完成，也算是对之前职业生涯的查漏补缺。 在训练营学习和自己死磕的最大区别就是，这里针对每一个难点，都有对应的文档资料可以参考，你不必大海捞针碰运气，不用一头雾水干着急，顺着图例的指引前进就对了，再不行，还有战友可以交流，实在搞不定，还有教练指点迷津……总之，再也不用冤死脑细胞，你一定能一路走下去……从这个角度望过去，我之前的“未雨绸缪”多少有点惨烈。如果再给我一次重新选择的机会，我宁愿不要那么“睿智”。 因为前期已经花了大量时间来搭建、配置环境，遇到的问题基本上已经解决了。所以Day2作业的主要时间都用来学习文档。之前毫无头绪地照着书上的指示配置，成功了就庆幸，失败了就焦急，根本不知所以然，心里完全没底。 回过头来学习文档，思路逐渐清晰，明白了那些命令的含义，最重要的是，知道了如何按需配置，终于从苍蝇模式过渡到蜜蜂模式。由此深刻体会到，参加训练营的最大意义，其实就是面对陌生地形，可以直接获得精准图例，迅速了解全貌。跳过苍蝇模式，直接开启蜜蜂模式，然后，循着光飞过去就是了。 基础知识应用回过头来看，自学营的整个作业体系设计得很精巧。先是熟悉工具、搭建环境，然后从打印一个最简单的“Hello World!”开始，让大家通过实现一个个简单而完整的功能把Python用起来，然后选取一个很实用主题层层递进。让大家亲身体会同样一个功能，如何一步步扩充、一步步改进，从简陋到完善，从笨拙到讲究，一步一步见证成长。 Day3看文档差不多花了5个小时，感觉实现计算器的逻辑应该很简单，本来想独立完成，但是，对Python的编程规则还不太熟悉，而且太久没写代码了，真的要动手时，居然又无从下手。真切感受到从0到1的艰难，于是Google了一个范例，又参阅了一位学友放在issue里的代码，总算可以下笔了。 先大概写出核心功能，然后不断尝试优化，这个过程中渐入佳境。因为工具用的不熟练，Jupyter lab和VS两边交替调试，走了不少弯路，不过，功夫不负有心人，最后终于实现了自己比较满意的效果。 Day4看文档1小时，独立写代码并调试1小时，感觉越来越得心应手。虽然还不能一气呵成，但是已经知道各种困惑应该去哪里查资料，进而顺利解决问题，每天都感觉到进步。 Day5深刻体会到在用中学和单纯用眼睛“学”的巨大差异了。看书的时候，感觉努努力都能看得懂，似乎明白该怎么用了。但是要写代码的时候，根本不是信手拈来啊，反复来回不停地翻文档，每一遍都有新收获。文档解决不了的问题，就问Google，总有前人留下的足迹，任何时候都不孤单。 Day5的任务知识覆盖面比较广，需要融会贯通，交叉使用，感受到了不同概念之间是如何产生联系的，终于体会到为什么笑来老师说《自学是门手艺》是《通往财富自由之路》的实践版了。 完成Day6作业之前，先把字符串相关内容仔细复习整理了一遍，认真做了笔记，又发现了不少仅仅靠阅读没能深入理解的内容，眼过千遍不如手过一遍！做作业倒是没用多少时间，但是感觉程序通用性不强，暂时却无力改进。后面很多内容还没看，温故知新，一步一个脚印，慢即是快。 Day7作业距离上次时间间隔有点长，因为我之前一直没能把书看完。第一部分好不容易看完了，到后面看着看着感觉前面的内容已经没什么印象了，所以，这次趁着边用边学，及时做笔记，让看过的内容都连贯起来。用纸笔记笔记收获很大。 本以为Day8的作业很简单，结果做的过程中困难重重。对于错误和异常的触发机制、对应的分类以及处理方式理解太粗浅，搞得自己摸不着头脑，乱试一通，代码编辑器用的也不熟练，加了断点忘记取消了，多亏教练指点，思路终于逐渐清晰，这只是个开始，目测前面埋伏还很多…… Day9大部分时间花在打开并读取json文件上了，查了很多资料，也浏览了学友们的作业，怎么试都不行。我也曾怀疑文件是空的，但是Windows无法直接打开，我又不知道也没想到用vscode就能打开json文件，结果文件果然是空的，我却以为是出错了，白费了很多功夫。经教练指点，终于顺利完成作业。感悟：对行家来说的常识，往往却是新手凭一己之力无法逾越的坎儿。这个好像不好补～ Day10作业耗时最多的地方其实是上一次隐藏的一个bug，只不过没影响到结果，所以没有发现。上次替换无用字符的时候，对于数字字符，想要进行统一处理，用这样的语句 if text[i] in range(1, 321) 跳过，不加到字典里。 今天采取同样的方法，没有得到预期效果，很纳闷，调好了很久，终于发现症结，其实文档里面的数字都被识别为字符了，那句代码根本没起作用。最后，还是老老实实继续用很笨的方式解决问题。 消化这本书感觉就像探索社会主义道路一样曲折，前进中还会有反复、还会有倒退。分明看的时候好像都懂了，但是走着走着，知识点之间串联不起来了，因此举步维艰，感觉只是把眼前的文字识别出来毫无意义，就只好从头来过。但是，仅靠眼睛形成的记忆是靠不住的，反复忘，太不牢固。直到开始用纸笔做笔记，之前与之擦肩而过的、想当然的一些知识点终于理解到位了。虽然只是把书上的很多内容抄到本子上，但是这个过程就是很神奇，收获的是仅靠阅读无法达到的高度。 生活场景拓展从Day11开始用真实场景演练了，之前只是人造应用场景。这两天的作业主题选取的是用机器人管理微信消息的应用场景，不能再贴近生活了！就像在试卷上答题和将所学应用于实践解决实际生活问题的区别一样，难度不是一个数量级了。如果没有作业单上的代码示例，只看文档是没法完成任务的，网上也很难找到合适的例子。 DAY12作业虽然已经提交，但是还有点疑惑。感觉实践作业不像之前的基础作业，做完了确实就知道是怎么回事儿了。实践作业如果没有参考根本完成不了。在一个项目文件里搜寻所需的零散信息，然后拼装起来实现一个完整而具体的功能，又一次手足无措。我们缺失的是什么，如何弥补呢？全面阅读文档，归纳、总结、融会贯通的能力不是一朝一夕练就的，但只要坚持、反复实践，总有功成的一天。 Day13作业又拖了好久，也没刻意计时。多多少少心里有点抵触情绪，感觉怎么看文档都只是一知半解，不如前面的基础作业有成就感，所以积极性不高。 最终下定决心照着教程把代码敲出来，因为之前看过文档，多少理解了一些，再自己敲一遍确实比只用眼睛看理解更深刻了。还有些不够明朗的细节留着以后慢慢消化吧。 由图例到实地曾经，我也是个“弄潮儿”，看不上的老师，怕被误导，上课睡觉，下课自学，成绩也还不错。所以，我以为自己很擅长自学并引以为豪，直到见识了自学高手的境界，才意识到自己所谓的“自学”只不过是很初级的阶段，前方还有很长的路要走，我却以为已经到达目的地了。这认知简直太误人了。 14天的训练营虽然要告一段落了，但这只是个起点，才刚刚学会看图例而已，千里之行只迈出了第一步。下一步继续研读《自学是门手艺》，随时查阅官方文档，进行关键知识点的总结、归纳、整理、组织，不断完善更新，直至刻在脑子里。同时不间断地练手，必须学以致用，否则只能永远停留在纸上谈兵的水平。 实地考察更有趣、更挑战、更刺激。手握地图，至少不会误入歧途。再出发，已经不是独自开荒了。路径清晰、路标醒目，就连远处的风景都依稀可见…… 如果说用代码实现一个计算器、一个九九乘法表什么的，对我们的生活改观并不大，那么写段代码管理微信消息，是一件多么高大上又体面的事情啊！微信几乎是每个人生活的一部分，不难想象，精通Python将如何改善我们的日常生活……用个不那么恰当的比喻：手里拿着锤子的人，看什么都是钉子。掌握一项技能就是拥有一种工具，用得顺手了，就停不下来了……期待那一天早早到来！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自学训练营学习4群-PYTHON入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050017-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A04%E7%BE%A4-PYTHON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：王晓镜 学号：1901050017 学习内容：14天python入门营 学习用时：40小时 学习笔记我选择的是预约制学习，可以自己学完一次作业以后马上申请学习后面的作业。 训练营带给我的 训练营的每日作业都会迫使我主动思考，逼迫我一字一句去阅读要求，不按照要求做就会完不成作业，强制改正了我阅读不仔细的问题。 社群式学习。不是单打独斗地面对困难，‘恐惧未知’这条恶龙不会在大脑中盘旋很久，因为有教练和同学在帮助着我，即使偶尔会深陷泥沼，只要我呼喊，他们就会立刻施于援手。学习效率大大提高。 养成了阅读官方档案的习惯。这一点非常重要，每天的作业都会给出官方档案的链接，在群里大家也会互相提醒，随时巩固这个好习惯。 学会了程序员思考，遇到难点，学会把它分成一小段一小段来解决，并且用自己熟知的知识尝试类比来解释给自己听。 深刻地认识到了借鉴优秀程序员的智慧结晶是非常重要的，有质量的输出的前提是要有质量地输入，如果能看懂优质代码，并为己用，这本身就是一种进步。 千里之行，始于足下—-训练营第一天 day1-day2作业完成自学训练营最能反映学习中不好的习惯。 收到“自学任务清单”，开始学习。清单表达的很清楚，但真的就是我看不见它，它一直在那里。清单里要求先看参考资料，我愣是自动掠过这一步，现在想来，真的是很佩服我的大脑，就这样习惯性地怕麻烦，找捷径，试图略过一切，然后还妄想能快速完成作业。 我在卡壳以后，冷静了下来，重新从清单1开始看，耐心地看了参考资料，认真地对待每一句话，这样竟然神奇地解决了每一个问题。这次我认识到想要解决问题，还是得克服自己的毛病。在做作业时，踏踏实实。 因为习惯不好，没有阅读官方文件。在一个小到不能再小的步骤上卡壳了1个小时。 在查看社群其他人的聊天中，找到了解决方案，在第一天截止时间前完成了第一天的打卡。 好久没体会过沉浸的感觉了，就是那种猛一抬头，一个小时过去了。 第一天的学习让我认识到想要解决问题，还是得克服自己的毛病。在做作业时，要踏踏实实。 纸上得来终觉浅，绝知此事须躬行—-训练营第二天 day3-day5作业完成看到群里的同学都在陆续地交作业（社群学习的好处，时刻督促自己），我停掉了“自我攻击的剧情”，心里开始接受一件事，那就是遇到不会的问题时是正常的，不久的将来一定会熟练掌握的。于是，心理突破了，脑子和手并用，完成作业的速度就提上来了。再加上，我不再以借鉴代码为耻，目的就是为了学习，我再借鉴的基础上再加上自己的理解，现在已经能够写出代码的一大部分了。自主学习加同学间互助式学习，具像化了李笑来老师说的： 很多人有莫名其妙的误解，以为“自学”（self-learning)就一定是“自己独自学”（solo-learning)，殊不知，自学也需要社交。 别怕！ 啥也别怕！没什么可怕的！ 收获总结： 学会了抄代码。不再谴责自己没用，心安理得地抄了三种代码，然后运行，改写代码，最后改写出了自己的代码。 敢于调试，以前总是怕出现问题，手心冒汗，后背冒汗，脑袋发麻，如今出现问题我就搜索问题是什么意思，然后冷静地去想办法解决。 学会去github里的issues找问题答案。 读书破万卷，下笔如有神—-训练营第三天 day6作业完成收获总结： 行之有效的方法就是大量阅读官方资料，因为是社群学习+github分布式交作业，所以可以看到很多同学的代码。学习+模仿，是我在3天时间内完成day1-6的任务的秘诀。输入有质量才是最好的进步方式。 读书不觉已春深，一寸光阴一寸金—-训练营第四天 day7-day10作业完成写python代码，做有用之事。在第四天，完成到了训练营day10的任务。 收获总结： 因为这几天的学习，让我深刻体会到了废寝忘食、孜孜不倦、目不转睛、聚精会神、茶饭不思的境界，心流时间可以达到3、4个小时不间断。 对阅读更是有了新的体会：一字不落的读，来回反复地读，不躲避，不放弃，迎着困难读。 对官方文档更加看重，对google也更加依赖，李笑来老师说的好： 学习任何东西，首先看官方文档或产品说明书，那些学习高手都是会先阅读官方文档的人。 能google出答案的问题，就不需要去麻烦别人.google、stackoverflow、wikipedia、youtube这都是自学人经常要去搜索的好地方。 千里之行，始于足下—-训练营第五天 day11-day12作业完成 眼是懒汉，手是好汉不怕，一点也不可怕，不难，一点也不难。 在这天，我清楚地感受到今天不想做作业地心情，抵触、逃避、恐慌、焦虑。。。。。。因为预知了困难，提前看GitHub 上的issues里都是关于day11作业的困惑和疑问，心里多少有些抵触。但是我知道只有做了才能解决，而不是空想。逃避没有任何用，把任务分解，一句话一句话地去实施。 随着着手敲代码的开始，这一天没有想象中困难，最后完成了day11-12的任务。 收获总结： 深刻理解了，写代码如同搭积木，一个函数如同一块乐高积木，只要一块一块加上去，就具像化了自己的目标。 一直听说python爬虫技术，今天终于得以实施，抓去了张小龙的演讲稿并做了处理，返回了邮件。 一直听说微信机器人，今天又亲自实施，和微信好友互动有无，她给我文章，我给她文章的数据，是自动的哦。 这次我好像真的很可以确信，学python不会再半途而废了，也许日后如同excel一样，用的机会越来越多了。 咬定青山不放松—-训练营第六天 day13作业未完成距离上一次提交作业已经过了两天，因为这次遇到了问题。求助issues和助教，还是未能解决。matplot绘制图表在我的电脑中显示不出来。无解中。 敏而好学，不耻下问—-训练营第7天 day13-14作业完成在google和其他同学的作业中寻找到答案，遇到两个大问题最终解决。1、matplot绘制图表在我的电脑中显示不出来。刚开始我以为代码没写对，后来用官方文档里的作业依然显示不出来。我才想到可能是其他问题，因为不自信，所以才会在代码上改了又改，耽误了时间，而真正问题不能解决。这是因为matplotlib的backend设置成了agg格式得在整个代码前加上 12import matplotlibmatplotlib.use（’TkAgg’) 而且要注意要在import matplotlib.pyplot前使用。2、微信返回数据乱码a.去fontplace下载SimHei字体，其他也可以。但网页打不开，我就选择了科学的方法，一次ok。b.把这个ttf文件手动添加到matplotlib的mpl_data里的tff文件夹里，这里都是已装字体。c.找到matplotlibrc文件，打开，这是不要害怕，直接找到font.sans-serif，在冒号后面打出：SimHei。关闭文件。在代码里添加 12from pylab import mplmpl.rcParams[‘font.sans-serif’] = [‘SimHei’] 事情到此，我的代码已经完全能显示了，并且中文也出来了。而且最重要的是通过此次的问题解决，让我对这次的作业代码非常熟悉，已经能变换地写出好几种相同功能的代码了。也算是有所收获。 最终的一天来到了，全部学完了训练营的任务，中间有困惑，有惊喜，最终收获的是满满的知识和弥足珍贵的自学体验，升级了自学的操作系统，对未来编程技能的使用充满了信心。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050017-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王晓镜学号：1901050017 工作背景中学老师 自我介绍我叫王晓镜。 学习python是想活在未来，用代码来为自己工作，用程序员思维来思考，用数据分析来判断形势和做出选择。 目前python入门营已学完，MIT课程自学已完成，正准备进入python进阶营学习。 我选择进入python入门营学习是做过最正确的选择，我发现与其说是学习写代码，不如说是如何学习程序员式思考方式。在紧张、有条不紊地14天学习过后，我看到了python的库的丰富，对于数据的抓取和可视化都不复杂，稍加学习就能掌握基本的数据读写和作出图表。但我知道代码易抄，背后却需要自己的思考和扎实的知识基础。我分析了自己对数据分析的兴趣，是源于想从看似复杂难辨的原始数据中找出事实，以让人一目了然的方式展现出来，从而基于事实作出判断。无论我的工作上还是业余生活上都非常需要这个技能，工作上我作为教务处老师，整天和成绩打交道，这是原始数据，并不需要抓取，但目前为止，只能用Excel展现学生成绩，而老师的教学质量和学生的成绩都无法关联，我先用python帮助自己；在其他方面，我想抓取我感兴趣的金融、时事数据并作出分析，这也需要python来帮助我。自学是可以的，但我在入门营体会到了自学社交的魅力，所以在开设进阶数据营后，我就来报名了。希望能让自己梳理好关于数据分析的系统思维，掌握数据分析的技能，随着学习的深入，对于自己想要的应用也许能更加细分化。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中学老师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100009-自学是门手艺-第一部分的七个章节]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901100009-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E4%B8%83%E4%B8%AA%E7%AB%A0%E8%8A%82%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100009 学习内容：《自学是门手艺》 学习用时：60min 学习笔记 刚刚完成14天自学营的学习。针对一些疑问也跟教练做了一些交流。了解到了学习Python早期就是要多看代码，多输入才能多输出。自学营毕业了算是入门了，后面几天继续阅读《自学是门手艺》以了解整本书的框架。 今天阅读了《自学是门手艺》的第一部分的七个章节。相比其他的计算机教程书，笑来老师的这本书阅读起来更加友好一些。了解了Python的一些最基本的知识。同时对自学营早期的一些作业内容，通过阅读书籍也多了一层理解。 很快理解函数从另外一个角度看只不过是 “程序员作为用户所使用的产品”。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自学训练营学习1群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901010056-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A01%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：马林同学 学号：1901010056 学习内容：Python 14 天入门 学习用时：总用时110.2小时 学习笔记day1~day14的记录day1学习时长:7个小时 学习内容 创建了两个自己的代码仓库，学会使用branch 和pull requst 在Github的仓库提交issue 通过Github Desktop 将ma-hellow-world 仓库克隆到了本地电脑 将公共作业的仓库克隆到了本地电脑，在本地仓库的exercises目录下藏剑文件 通过Github桌面客户端将本第电脑的变更推送到自己的账户下的作业仓库 向远程作业仓库的master分支发起了pull request 收获 pull request are zhe heart of the collaboration shows diffs or differences of the content from both branch make adn commit changes 和open a pull request for changes to the develop和merge your pull request 在三个步骤在初期的时候搞不明白 认识了不少单词和句子 在找按钮的过程中，经常忽略下拉找找 对于一些难词很多的生词，可以直接字典翻译，提高效率 day2学习时长:7个小时 收获 锻炼自己，通过找、 问的方式去解决问题。 顺利下载并安装了Anaconda，并在其界面安装了VScode，Jupyter Notebook 和 JupyterLab. 在 vscode 中配置 Python 环境选择特定环境，应该输入“Python: Select Interpreter”进行选择。但一直没有对应的选项。通过糖总发总的issue链接找到答案。要搜索“language”——“Configure Display Language”——将”locale”:”en”修改为”locale”:”en-US”，保存。重启。 用jupiter note book 阅读笑来老师新书，被网页上的一个烟雾弹，所困住。经过助教点播，才解决，发现也不是大问题。 day3学习时长:4个小时 收获 在自己的编码器上跑出程序 由于认真看过笑来老师的新书，再结合google翻译，看起来英文文档还比较顺畅，但是一下子也没好好吸收 感悟 实际的操作代码很多都是可以从网上找到的。这对于初步阶段的我很有利用价值。 用好google和google 翻译，似乎没有什么事是解决不了的 day4学习时长:6个小时 遇到问题 当拿到题时，没有任何头绪。知道会用到条件判断和循环语句，但是不知道怎么用。最后在issue上解决了问题 在写代码时忘了加冒号，导致运行失败 在写while语句时，发现空格也非常重要，否则，程序是没办法成功的 感悟 细心也非常重要 把学的内容解释，可以在代码中加井号，解释出来，加深理解 day5学习时长:9.5个小时 学习内容 字符串的基本处理，将文本里的单词进行替换，剔除不想要的单词，翻转单词中的大小写字母 用字典统计字符串样本中英文单词出现的次数，按照出现次数从大到小进行排列，注意排除符号 将数组顺序进行翻转，用字符符串切片方式取出第三到第八个字符，将获得的字符进行翻转，将结果转化成整型，分别转化成二进制，八进制，十六进制 学习笑来老师书上的内容，知道了笑来老师书的代码是可以直接在lab上直接运行的操作，并且可以改着玩 将单词中包含ea的单词除去的时候，一开始参考用del但是后面的怎么跑都不成功。后来又参考另外几名同学的作业，和issue，才知道del 的用途一般用来删除数组中的一个元素，或者删除一个变量 感悟 day5的实用性很强，有四六级或者考研的所有的卷子text,就可以对里面所有的单词出现的频率进行统计，从而把时间都花在记忆高频率不会的单词上，只是最后转化成二进制，八进制，十六进制，暂时还不知道有什么用 在打代码的时候，需要注意冒号是否打了 可以把笑来老师的书提上日程上来，对于增加对python有很大帮助，上面的代码可以直接修改，对于无论是函数，数据类型，还是其中的逻辑关系的理解都又很大的帮助 程序跑错误后的提示，也至关重要，提示里的单词一定要明白意思 似乎是上点门道了。结合笑来老师的书，提供了很多的方便 day6学习时长:5个小时 学习内容 封装统计英文单词词频的函数。这个任务是基于昨天 的内容 封装统计中文汉字字频的函数，判断是不是汉字这个问题需要一定的时间 感悟 虽然作业时做下来了，但是作业里面还是有很多东西一知半解，无论是函数的运用，还是字符的形式，等等一系列内容都是需要加强训练的，都是需要时间和精力的投入才能慢慢上手的 已经完成的同学的作业也是有好有坏，有的非常的简洁，有的非常的繁琐，再参考的时候一定要多看几个，比较一下 day5的Python中的禅宗中的这句话”面对困惑，拒绝猜测的诱惑”给自己提了个醒，不要懒的查找就去猜测函数的功能或者不会的内容 day7学习时长:10.5个小时 感悟 冥想对于编程来说有很大的帮助，因为无论是调试一个程序，还是阅读一段自己理解的概念，都能够让自己很清楚很客观认识自己的现状，自己的处境，自己正在挣扎在一个怎样的问题上。缺乏元认知能力的话，很容易陷入低级的困惑当中，甚至即使过了很长时间自己的对问题的思考都得不到推进。 做题的时候，可以把笔记本就打开，遇到不会的问题，就敲到上面，遇到自己不熟悉的知识点就敲到上面。因为不会的都是需要自己加强的，所以敲一遍一点都不过分，甚至多敲几遍都不过分 在把笑来老师的part1再看一遍，发现这一部分需要多看几遍，不然不容易掌握，多看一遍对全局都有一个更深刻的理解 把对英文的词频和中文的字频包装成一个函数，需要的时候随时调用，这样真的剩了不少事 知识点总结 循环语句可能带有一个else子句；这个else子句它会在循环遍历完列表的时候被执行（另一种情况暂时没遇到先不讨论），但是不会在循环被break语句终止时被执行。 break 它也属于一个子句中的一个条件，表示跳出最近的for循环，（while没遇到暂时不讨论），控制流程往下跑。但是一种情况比较特殊就是往下跑的时候遇到else语句，此时else语句不被执行 琢磨流程控制中的break和continue需要时间多点。continue语句看官方文档稍微好理解，就是当条件被满足时，也就是continue被执行时，流程被控制往上跑，继续上面的循环 易错点 在mydouble文件夹的同级目录下，创建main.py文件。意思就文件夹mydouble和文件main.py都出现在同一个页面中，容易犯的误区就是，看到，一个文件夹，一个文件，想当然地认为这个文件就在文件夹里。 day8学习时长:3.7个小时 学习收获 Ctrl +Backspace是删除整个单词 Ctrl+左右移动键是光标来回在整个单词间跳动 Tab +右移动键 可以自动补全函数和前面已经输入过的字符 感悟 尝试一下，通过写的方式将自己的思想过程具体化，避免失去重点，让任务得不到推进。 一切提升效率的东西都要尽快第掌握 day9学习时长:11.5个小时 卡点 不知道怎么把VS code给玩坏了，以前的所有作业的程序都运行不了，但是发现前已经花了好多时间在上面这是第一个卡点，卡了我不少时间，最后在折腾不行，听教练的建议又重新安装了一遍，随后才正常运转 关于tang300.json路径的设置，我一直担忧是自己的运行系统是C盘，但是作业在D盘的原因，在参考前辈的作业，什么情况都有，况且每个人的路径都不一样，苦苦挣扎，也卡了不少时间，最后在YouTube上的相关视频找到启发，让程序给运行成功了 在找问题的时候，由把本地文件的仓库的文件位置给变动了，所以就是在desktop上费了点时间 感悟 累坏了，不过在通过自己的努力查找，让程序运行成功的一瞬间，感觉自己的真牛，差点都认怂了，幸好没放弃，充足的时间预算也相当重要， day 10学习时长:11个小时 下载完jieba不知道怎样安装，在issue上虽然有个方法，但是在终端输入指令根本不会，在教练逯彬杨的帮助下，又查阅相关的资料解决 程序死活运行不了，以前的做的有的也运行不了，教练协助，修改了部分代码，还是不行，尝试了，各种办法以后（有一个尝试把操作页面改成中文了），为下一步发现问题铺一步路，尝试到11点，和辅导员老白的聊天中，他提了一句，配置问题，然后第二天发现有一个bug确实是配置问题，以前做的能运行了 找不到路径问题，由于前段时间，一不小心玩坏了本地，删除了以后，导致路径发现问题，后来又把程序中的路径改了过来 程序运行找不到mydoule中的stats_world，最后索性都在后面加了一个数字，最后终于成功 感悟 做的时候，不知道是以前的坑，还是现在的坑在等着你，让你去跳，要做多就是找出坑，把它填平，确保自己不会掉下去。 时间预算也是非常重要的考虑因素，如果时间预算不充裕的话，做这个难度还确实不小 主动性也是一个十分重要的因素，卡到一个部分，查完后还一脸懵逼，就问一下，教练十分敬业的帮助你，旁敲侧击地地提醒你，都会帮你把作业给往下推进。但是，前提是，你的主动性得强，关键在你自己。 day11学习时长:20个小时 卡点 安装文档解析库，折腾了一波 用requests请求公众号文章连接，获取返回结果response,把微信公众号的正文提取出来 开通邮箱这个权限后，输入的不是邮箱密码而是授权码，而且输入的位置是在终端 最后是在自己的邮箱先测试，反复第想 感悟 里面的步骤一步一步来，一步成功后，在继续下面的步骤，比如print出来，看这一步成功后再进行一步，避免问题堆积 想起一首歌词，“这一路上走走停停，顺着少年漂流的痕迹”，因为事比较多，所以自学这个也是挺艰难的，这几天都是，做做停停，不过只要不放弃，就有机会，如果放弃了，那这件事肯定凉凉。 辅导员和教练，助教的存在真的很重要，虽然培养的是自学能力，但是如果只靠自己而不去向前辈请教，我自己肯定做不到并且极其容易放弃，我想很多人肯定也做不到，所以有什么困惑，多和他们交流交流，收获绝对是很大的 day12学习时长:5.5个小时 卡点 安装wxpy,显示需要升级pip，根据提示输入指令后，又出现安装环境错误，直接把错误复制，在百度中搜索后，根据简书上的提示，进行改写，又出现错误。然后发现，在升级pip 的时候的命令少写一个数字，填上后，错误消失，在cmd 中查看晒否安装wxpy成功，成功后继续下一步 在终端测试得回来的数据不显示 自动接受的文章，把参考资料的延申都大致看完后，参考实例代码，运行琢磨，发现需要，把最后的embed（）函数也剪切过来，才能检验前几段程序，可是还是没解决问题，又在网上转一圈后，在何教练的点播下，又改了一行代码，解决 文本出现了，但是，词频没出现，经过琢磨后， 发现把stats_word11名字，改一下，解决 感悟 在卡点三花费时间最长，最后教练一句话解决，教练的重要性，不言自明 作业是作业，但是相关的衍生工作，都够自己的琢磨一整子的，就比如今天的wxpy: 用 Python 玩微信 也刚好在室友的帮助下，调试很多遍成功，相关实用性的训练有时需要求助的不止一个人 经过这段时间的思考，认为，自学的常态是，碰到问题，明确问题，想办法解决问题。其中最为关键的是想办法解决问题，相关论坛的，内网和外网，教练们，等等，想各种渠道去解决问题。 day13学习时长:3.5个小时 卡点 参考matplotlib的资料，将day12中的结果生成一张图片，将演示代码直接复制能出现一样的图片结果&gt;现在想办法在这个代码改改，把day12的结果想办法引进来 将返回给好友的内容以表的形式出现，参考作业代码不行，通过百度，直接把上面的结果转化成list形式，可以返回给好友 感悟 day13新增的部分更像是一个工具，一个将表格转换成图片的工具，将里面的东西稍微变变型就能弄出自己的东西 day14学习时长:6个小时 感悟 这一路走过来，像极了过关的游戏的感觉，你会遇到各种各样的卡点，不要怕，那是进步过关的入口 最后还是要感谢教练、辅导员、助教的帮助和鼓励，才让我有能力、有信心、有勇气去与困难做斗争，去把时间当朋友，披荆斩浪，勇往直前。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010056-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：马林学号：1901010056 工作背景大学狗 自我介绍 自我介绍:有一年七个月时长的时间记录者，这个习惯加速了自己的进步，所以很多场合都很想说两句，希望大家可以一块时间记录，加速成长。最后也非常高兴认识大家，希望能互相学习，互相帮助，互相鼓励，共同进步。 我学习Python的目的目前是为了将来的工作加筹码，“独善其身”完了以后，希望可以“平天下”，哈哈说得有点大了，目前希望用途： 可以用在对Python领域工作岗位的分析上 对自己的两本时间记录数据的分析上 如果时间记录分析出的各项数据，能给自己带来清楚的认知以及未来计划的优良改善的话，我希望可以将功能落地，组建一个社群去帮助更多伙伴养成时间记录，分析时间记录的好习惯。 目前的学习阶段：Python入门营的学习内容，MIT入门课，Python相关书籍的阅读 疑惑：Python的细分领域下实际的工作内容有哪些？学员所学的内容有没有对平时的学习工作立即产生帮助的例子？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>大学生</tag>
        <tag>农学专业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学是门手艺(1.5.2)-Day18]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901050119-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-1-5-2-Day18%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901050119 学习内容：《自学是门手艺》- 1.5.2 值及其相应的运算 学习用时：1.5h 学习笔记收获总结先把书读厚再读薄，试着借用作者的视角，通过归纳、总结，复现每一部分内容的知识结构。最后，还要能再次把书读厚。如果能做到像作者那样去思考，那么，头脑中提炼出的知识结构就可以随时还原，就像根据目录检索正文一样。这样，一本书就彻底消化吸收了。 Daily Tips 这一章主要介绍了基础数据类型的运算细节。而除了基础数据类型，我们需要由它们组合起来的更多复杂数据类型。但无论数据的类型是什么，被操作符操作的总是该数据的值。 值是程序的基础成分（Building blocks） 常量的值就是它们字面所表达的值。变量必须先赋值才能使用，即，要先把一个值保存到变量中，它才能在其后被运算。 在 Python 中每个函数都有返回值，默认返回 None 既然有不同类型的数据，它们就分别对应着不同类型的值。通常相同类型的值才能相互运算。在不得不对不同类型的值进行运算之前，总是要事先做 Type Casting（类型转换）。 函数就相当于各种事先写好的子程序，给它传递一个值，它会对其进行运算，而后返回一个值（最起码返回一个 None）。 每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050119-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Galaxy学号：1901050119 工作背景全职妈妈+自由职业者 自我介绍先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>全职妈妈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-MIT60001-LECTURE1]]></title>
    <url>%2FMIT60001%2F1901020043%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5MIT%20Python%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 1 +Python 编程导论（第2版）（第1章+第2章的2.1） 学习用时：4小时 学习笔记收获总结： Computers only know what you tell them. Computers only do what you tell them to do. 计算机能且只能做两件事——执行计算与保存计算结果(perform calculations and remember results)，但它把这两件事做到极致。 计算机思维： 七种关系：1.大和小 2.快和慢 3.多维度和单一维度 4.网络和个体 5.自顶向下和自底向上 6.全局和局部 7.成本和表现 两个原则：1.等价性原则 2.模块化原则 ——（吴军的谷歌方法论） 算法：是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。（简单步骤，控制流，何时结束） 通用图灵机：可以接受任意一个图灵机 M 的编码 ，然后模拟 M 的运作。 邱奇-图灵论题：任何在算法上可计算的问题同样可由图灵机计算。（如果一个函数是可计算的，那么一定可以通过对图灵机进行编程实现这种计算。） 停机问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”,所有现代编程语言都是图灵完备的。 每种编程语言都有基本结构、语法、静态语义和语义。 Python的基本结构包括字面量和中缀操作符；语法定义了字符和符号组成句子的正确形式；静态语义定义了哪些语法有效的句子是有意义的；语义为每个语法正确又没有静态语义错误的句子关联一个含义。 程序如果没有正确运行，就应该表现出明显的错误。只要有可能，我们都应该以这种方式编写程序。 对象是Python程序处理的核心元素。Python有4类标量对象：int，float，bool，None 在Python中，变量仅是名称，没有其他意义（非常重要）。变量名可以包含大写字母、小写字母、数字（不能以数字开头）和特殊字符_，变量名称大小写敏感，保留字不能做变量名。 恰当的选择变量名和添加注释是提高程序可读性的好方法。 总结：看英文字幕虽然很难但是不会像中文字幕令人不舒服；明确计算机的边界，能做什么，不能做什么；学习计算机思维的相关知识很重要，得到有很多文章讲解，应该再看一些相关书籍；个人偏好一些概念的认真理解，会额外耗费很多时间，是否有用在以后的学习中会验证；养成好的编程习惯，先从变量名和注释开始；多输入代码，刻意练习的技巧可以考虑如何用在这里。 遇到的难点与问题（是否解决）：对停机问题的理解还不够，先放放，过一周再看。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part3)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D07 Part 3 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 enumerate 的使用 程序代码（完成提示功能）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' my_word = my_word.replace(' ', '') if len(my_word) == len(other_word): hidden_letters = [] for i,c in enumerate(my_word): if c == other_word[i]: continue elif c == '_': hidden_letters.append(other_word[i]) else: return False for hidden_letter in hidden_letters: if hidden_letter in my_word: return False return True else: return False def show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' my_word = my_word.replace(' ', '') possible_matches = [] for word in wordlist: if match_with_gaps(my_word, word): possible_matches.append(word) print(" ".join(possible_matches))def hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if letter == '*': print("Possible word matches are:") show_possible_matches(current_guessed_word) continue if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. # secret_word = choose_word(wordlist) # secret_word = 'else' # hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'tact' hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010000-MIT-自学 MIT 原版书 第三章]]></title>
    <url>%2FMIT60001%2F1901010000-MIT-%E8%87%AA%E5%AD%A6-MIT-%E5%8E%9F%E7%89%88%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901010000 学习内容：自学 MIT 原版书 第三章一些简单的数值程序/其他补充阅读材料 学习用时：60min 学习笔记 完成30天打卡后，首次来完成当周打卡任务。发现Python健脑最好别间隔太久，要不一回来看就又觉得有丢丢陌生 这章其实就还是在继续复习while循环和for循环的基本编写方式。喜欢书里的写法，每次讲解完程序就会写”有经验的程序员一般是这样做的”。里面有一个例子是程序会永远运行下去，因为循环体没有减少两个参数之前的差距。经验丰富的程序员经常会插入一些print语句，比如测试递减函数是否真的递减。 这也是优秀教练的教法，比如今天我看到蔡教练给姜翔发的google工程师的编写规范·。下面也也发给大家一起参考。 看到特别好玩的三个语录分享给大家一乐： 这个”电话”有太多缺点，没法当作真正的通信手段。这东西本身对我们没有价值。 ——西联公司1976年内部备忘录 我看全世界对计算机的需求量总共可能只有五台。 ——托马斯沃森，IBM董事长，1943年 没有任何理由能够证明，人人都想在家里拥有一台计算机。 ——肯奥尔森，DEC公司总裁和创始人，1977年]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901030012-MIT-Python课-lecture 8]]></title>
    <url>%2FMIT60001%2F1901030012-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-lecture8notes37%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901030012 学习内容：MIT第8课视频文稿p7-8及幻灯片p12-13 学习用时：67min Notes no.: Day37 学习笔记 assigned vs. equal to So now we have sort of a nice class. It’s very simple, but we can start actually creating coordinate objects. So when you create coordinate objects, you’re creating instances of the class. So this line here, C is equal to coordinate 3,4, is going to call the init method. It’s going to call the init method with x is equal to 3 and y is equal to 4. Cat notes:Here when prof. “read” this piece of codes, “=” read as “equal to” however be aware of its actual specific meaning in Python, “=” means to assign or passing it all the variables, “==” means to check operational “equal to”, and also bear in mind about “!=” —not equal to, when using in arguments to demonstrate boolean operation. dot notionWe can access the data attributes using this dot notation and we’ve seen that before, right?When we’ve worked with lists we’d say something like, L dot append, right, when we create a list. So the same dot notation can be used with your own objects in order to access data attributes. So here, this is going to print 3 because the x value for object C is 3, and the next line, print origin x is going to print 0 because the x value for the object origin is 0. init methodWe have to find the init method so we have a way to create objects when we use the class. And then we can access the data attributes. But that’s kind of lame, right, because there isn’t anything cool we can do with it. add more methodsRemember methods are going to be procedural attributes that allow us to interact with our object. Methods are like functions except that there’s a couple of differences which you’ll see in a moment. eg: “distance”So notice this method is pretty much like a function, right? You have DF, some name, it takes in parameters. It does some stuff and then it returns a value. The only difference is the fact that you have a self here as the first thing and the fact that you always have to be conscious about whose data attributes you’re accessing. So you have to use the dot notation in order to decide whose data attributes you want access. So we’ve defined the method here, distance. Euclidean distance formulaSo here I’m going to just implement the Euclidean distance formula, which is x1 minus x2 squared, plus y1 minus y2 squared, and square root of all that. So that’s what I’m doing inside here. 12345678class Coordinate(object): def __init__(self, x, y): self.x = x self.y = y def distance(self, other): x_diff_sq = (self.x - other.x) ** 2 y_diff_sq = (self.y - other.y) ** 2 return (x_diff_sq + y_diff_sq) ** 0.5 Other than self and dot notation, methods behave like functions (take params, do operations, return) 我看到的时间和实践是最好的朋友，当和最好的朋友在一起的时候，人是真诚、充实、无需谎言的。我们的Camp给我们提供了默认的methods来让我们和自己最好的朋友尽可能的相处，我们也许还不知道default的缘由，但是，能使用到这些methods然后逐渐地通过一步一步的迈进能看到default以及缘由，我们自己就可以create我们的methods，与别人交流，供别人使用，我觉得我这次真的看到了希望。下一步是，build it up。感谢营友们的美好，这个世界有你们真好！！！加油！]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part1)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part1)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D05 Part 1 作业要求（简述）:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学会 not in list 的写法 程序代码（完成三个基本辅助函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part2)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D06 Part 2 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'else' hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartC)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D04 Part C 作业要求（截取）:Part C: Finding the right amount to save away In Part B, you had a chance to explore how both the percentage of your salary that you save each month and your annual raise affect how long it takes you to save for a down payment. This is nice, but suppose you want to set a particular goal, e.g. to be able to afford the down payment in three years. How much should you save each month to achieve this? In this problem, you are going to write a program to answer that question. To simplify things, assume: Your semi­annual raise is .07 (7%) Your investments have an annual return of 0.04 (4%) The down payment is 0.25 (25%) of the cost of the house The cost of the house that you are saving for is $1M. You are now going to try to find the best rate of savings to achieve a down payment on a $1M house in 36 months. Since hitting this exactly is a challenge, we simply want your savings to be within $100 of the required down payment. In ps1c.py, write a program to calculate the best savings rate, as a function of your starting salary. You should use bisection search to help you do this efficiently. You should keep track of the number of steps it takes your bisections search to finish. You should be able to reuse some of the code you wrote for part B in this problem. Because we are searching for a value that is in principle a float, we are going to limit ourselves to two decimals of accuracy (i.e., we may want to save at 7.04% ­­ or 0.0704 in decimal – but we are not going to worry about the difference between 7.041% and 7.039%). This means we can search for an integer between 0 and 10000 (using integer division), and then convert it to a decimal percentage (using float division) to use when we are calculating the current_savings after 36 months. By using this range, there are only a finite number of numbers that we are searching over, as opposed to the infinite number of decimals between 0 and 1. This range will help prevent infinite loops. The reason we use 0 to 10000 is to account for two additional decimal places in the range 0% to 100%. Your code should print out a decimal (e.g. 0.0704 for 7.04%). Try different inputs for your starting salary, and see how the percentage you need to save changes to reach your desired down payment. Also keep in mind it may not be possible for to save a down payment in a year and a half for some salaries. In this case your function should notify the user that it is not possible to save for the down payment in 36 months with a print statement. Please make your program print results in the format shown in the test cases below. Note: There are multiple right ways to implement bisection search/number of steps so your results may not perfectly match those of the test case. 作业心得PartC的作业，根据以下前提条件，计算如果3年内要付首付，每月最优存款比例： 年薪涨幅是 .07 (7%) 投资年回报率是 0.04 (4%) 首付是总款的0.25(25%) 总款是1百万 有几点需要注意： 需要用到 bisection search 算法 每月存款比例保留小数点后两位，比如7.041%，使用浮点数表示为 0.0741，所以我们可以利用0-10000的整数来做算法计算，最后再转化为float 本次作业学习到以下知识点： 需要用到 bisection search 算法，可以参考以下链接：https://stackoverflow.com/questions/47196917/python-bisection-search-exercise python 在函数外定义变量，默认是全局变量，在函数中默认能够读取，但无法修改，参考：https://www.programiz.com/python-programming/global-keyword 程序逻辑引入了全局变量，显得不太优雅，仍有改善空间。 程序实现的时候，参考了一下连接：https://github.com/iamwhil/6.0001（运行结果与作业中的测试相符）https://github.com/kaizenflow/6.0001-ps1（无法得到正确的结果） 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 起始年薪annual_salary = 1500000# annual_salary = float(input("Enter the starting salary:"))# 房价total_cost = 1000000# 薪资涨幅semi_annual_raise = 0.07# 首付比例portion_down_payment = 0.25# 存款年化率R = 0.04deep = 0# 首付down_payment = total_cost * portion_down_paymentlast_portion_saved = Falsedef month_counter(current_savings, annual_salary, portion_saved): # 当前月份 month_count = 1 # while loop while True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*R/12 # 如果存款 和 首付，相差不到100，也算达成条件 if current_savings &gt;= down_payment: break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1 return [month_count, current_savings]def bisection_search(portion_saved_rates, annual_salary): global last_portion_saved global deep deep += 1 # 计算中位数，【//】 符合表示除法的商是整数 if len(portion_saved_rates) == 1: return last_portion_saved middle = len(portion_saved_rates) // 2 portion_saved = portion_saved_rates[middle] / 10000 init_current_savings = 0 # 如何计算的月份与预期相等 res = month_counter(init_current_savings, annual_salary, portion_saved) month_count = res[0] current_savings = res[1] # print(portion_saved_rates, month_count, current_savings, portion_saved, abs(current_savings - down_payment)) if month_count == month_count_expect: last_portion_saved = portion_saved_rates[middle] if abs(current_savings - down_payment) &gt; 100: return bisection_search(portion_saved_rates[:middle], annual_salary) else: return portion_saved_rates[middle] elif month_count &gt; month_count_expect: # 计算的月份比期望的大，说明存款比例少了,要提升比例 # print(portion_saved_rates[:middle]) return bisection_search(portion_saved_rates[middle:], annual_salary) else: return bisection_search(portion_saved_rates[:middle], annual_salary)portion_saved_rates = range(0, 10000)month_count_expect = 36res = bisection_search(portion_saved_rates, annual_salary)if res is False: print("It is not possible to pay the down payment in three years.")else: print("Best savings rate: &#123;&#125;".format(res/10000)) print(res/10000) print("Steps in bisection search: &#123;&#125;".format(deep))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartB)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D03 Part A 作业要求（截取）:Part B: Saving, with a raise Background In Part A, we unrealistically assumed that your salary didn’t change. But you are an MIT graduate, and clearly you are going to be worth more to your company over time! So we are going to build on your solution to Part A by factoring in a raise every six months. In ps1b.py, copy your solution to Part A (as we are going to reuse much of that machinery). Modify your program to include the following Have the user input a semi-annual salary raise semi_annual_raise (as a decimal percentage) After the 6 th month, increase your salary by that percentage. Do the same after the 12 th month, the 18 th month, and so on. Write a program to calculate how many months it will take you save up enough money for a down payment. LIke before, assume that your investments earn a return of r = 0.04 (or 4%) and the required down payment percentage is 0.25 (or 25%). Have the user enter the following variables: The starting annual salary (annual_salary) The percentage of salary to be saved (portion_saved) The cost of your dream home (total_cost) The semi­annual salary raise (semi_annual_raise) 作业心得PartB的作业其实和PartA的整体思路差不多，主要是增加了一个变动收入，没6个月加薪 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 提薪的比率（semi_annual_raise） 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。存款由三部分组成： 已有存款 月薪按比例存款；月薪每6个月有涨幅（这里是重点，原文是after 6th month，也就是第7个月薪资变动才生效，而不是第6个月） 每月投资回报 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 起始年薪# annual_salary = 75000annual_salary = float(input("Enter your annual salary:"))# 每月薪资存款比例# portion_saved = .05portion_saved = float(input("Enter the percent of your salary to save, as a decimal:"))# 房价# total_cost = 1500000total_cost = float(input("Enter the cost of your dream home:"))# 薪资涨幅# semi_annual_raise = 0.05semi_annual_raise = float(input("The semi­annual salary raise:"))# 首付比例portion_down_payment = 0.25# 存款年化率r = 0.04# 当前存款current_savings = 0# 当前月份month_count = 1# 首付down_payment = total_cost * portion_down_payment# while loopwhile True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 # print("第&#123;&#125;个月，薪水&#123;&#125;，存款&#123;&#125;，首付&#123;&#125;".format(month_count, annual_salary, current_savings, down_payment)) if current_savings &gt;= down_payment: print("Number of months: &#123;&#125;".format(month_count)) break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartA)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartA)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D02 Part A 作业要求（截取）:Part A: House Hunting You have graduated from MIT and now have a great job! You move to the San Francisco Bay Area and decide that you want to start saving to buy a house. As housing prices are very high in the Bay Area, you realize you are going to have to save for several years before you can afford to make the down payment on a house. In Part A, we are going to determine how long it will take you to save enough money to make the down payment given the following assumptions: Call the cost of your dream home total_cost. Call the portion of the cost needed for a down payment portion_down_payment. For simplicity, assume that portion_down_payment = 0.25 (25%). Call the amount that you have saved thus far current_savings. You start with a current savings of $0. Assume that you invest your current savings wisely, with an annual return of r (in other words, at the end of each month, you receive an additional current_savings*r/12 funds to put into your savings – the 12 is because r is an annual rate). Assume that your investments earn a return of r = 0.04 (4%). Assume your annual salary is annual_salary. Assume you are going to dedicate a certain amount of your salary each month to saving for the down payment. Call that portion_saved. This variable should be in decimal form (i.e. 0.1 for 10%). At the end of each month, your savings will be increased by the return on your investment, plus a percentage of your monthly salary (annual salary / 12). Write a program to calculate how many months it will take you to save up enough money for a down payment. You will want your main variables to be floats, so you should cast user inputs to floats. Your program should ask the user to enter the following variables: The starting annual salary (annual_salary) The portion of salary to be saved (portion_saved) The cost of your dream home (total_cost) 作业心得光看懂英文作业已经蛮吃力了，哈哈，简化作业说明如下： 买房子的总费用为 total_cost 首付（down payment）为25%, portion_down_payment = 0.25 存款为 current_savings，从0开始 存款有投资，年回报率（an annual return）为r（0.04），所以每月额外收入为 current_savings*r/12 年薪为 annual_salary 从每月薪资中，固定比例用于首付，这个比率设为 portion_saved 每个月的收入来源，主要是 投资回报 + 每月工资 monthly salary（annual salary / 12） 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。 存款由三部分组成： 已有存款 月薪按比例存款 每月投资回报 程序代码# 起始年薪 # annual_salary = 120000 annual_salary = float(input("Enter your annual salary:")) # 每月薪资存款比例 # portion_saved = .10 portion_saved = float(input("Enter the percent of your salary to save, as a decimal:")) # 房价 # total_cost = 1000000 total_cost = float(input("Enter the cost of your dream home:")) # 首付比例 portion_down_payment = 0.25 # 存款年化率 r = 0.04 # 当前存款 current_savings = 0 month_count = 1 # 首付 down_payment = total_cost * portion_down_payment while True: # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 if current_savings &gt;= down_payment: print("Number of months: {}".format(month_count)) break # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet0]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet0%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 0 (ZIP - 2.0MB) 打卡天数：D01 作业要求（简述）:Write a program that does the following in order: Asks the user to enter a number “x”; Asks the user to enter a number “y”; Prints out number “x”, raised to the power “y”. Prints out the log (base 2) of “x”. Use Spyder to create your program, and save your code in a file named ‘ps0.py’. An example of an interaction with your program is shown below. The words printed in blue are ones the computer should print, based on your commands, while the words in black are an example of a user’s input. The colors are simply here to help you distinguish the two components. 1234Enter number x: 2 Enter number y: 3 X**y = 8log(x) = 1 作业心得根据提示，本章作业涉及的知识点如下： print / input 函数的使用，可以参考以下文章 input()函数 print()函数 python中的基础数学运算，pow函数; math库的math.pow/log2函数 pow()函数 math.log2()函数 math.pow()函数 numpy库的log2函数 https://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html 程序的实现过程中，遇到几点需要注意的： input函数返回的是str类型，需要通过int函数转化才能进行运算，否则会报错 TypeError: unsupported operand type(s) for ** or pow(): ‘str’ and ‘int’” 一般的数据计算，math库也足够了，numpy提供了更多更方便的函数 程序代码1234567891011import mathimport numpy# 因为要参与计算，所以需要使用int函数来转化x = int(input("Enter number x:"))y = int(input("Enter number y:"))# 使用内置函数和math库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(pow(x, y), int(math.log2(x))))# 使用numpy库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(numpy.power(x, y), int(numpy.log2(x))))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
</search>
